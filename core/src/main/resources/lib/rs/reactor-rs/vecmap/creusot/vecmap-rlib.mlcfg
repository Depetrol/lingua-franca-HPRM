
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use mach.int.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use mach.int.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Vecmap_VecMap_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_vecmap 'k 'v =
    | C_VecMap (Alloc_Vec_Vec_Type.t_vec ('k, 'v) (Alloc_Alloc_Global_Type.t_global))
    
  let function vecmap_v (self : t_vecmap 'k 'v) : Alloc_Vec_Vec_Type.t_vec ('k, 'v) (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VecMap a -> a
      end
end
module Core_Num_Impl12_Max_Stub
  use mach.int.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl12_Max
  use mach.int.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface
  type t
  type a
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . Seq.length (shallow_model self) <= UInt64.to_int Max0.mAX'
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . Seq.length (shallow_model self) <= UInt64.to_int Max0.mAX'
end
module CreusotContracts_Model_DeepModel_DeepModelTy_Type
  type self
  type deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Stub
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Interface
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module Vecmap_Impl0_KeySeq_Stub
  type k
  type v
  use seq.Seq
  use mach.int.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  function key_seq [#"../src/lib.rs" 55 4 55 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    
end
module Vecmap_Impl0_KeySeq_Interface
  type k
  type v
  use seq.Seq
  use mach.int.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  function key_seq [#"../src/lib.rs" 55 4 55 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    
  axiom key_seq_spec : forall self : Vecmap_VecMap_Type.t_vecmap k v . [#"../src/lib.rs" 52 4 54 56] Seq.length (key_seq self) = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (key_seq self) i = DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a))
end
module Vecmap_Impl0_KeySeq
  type k
  type v
  use seq.Seq
  use mach.int.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  function key_seq [#"../src/lib.rs" 55 4 55 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    
  val key_seq [#"../src/lib.rs" 55 4 55 43] (self : Vecmap_VecMap_Type.t_vecmap k v) : Seq.seq DeepModelTy0.deepModelTy
    ensures { result = key_seq self }
    
  axiom key_seq_spec : forall self : Vecmap_VecMap_Type.t_vecmap k v . [#"../src/lib.rs" 52 4 54 56] Seq.length (key_seq self) = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (key_seq self) i = DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a))
end
module Core_Cmp_Ordering_Type
  type t_ordering  =
    | C_Less
    | C_Equal
    | C_Greater
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : self) (_2' : self) : Core_Cmp_Ordering_Type.t_ordering
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : self) (_2' : self) : Core_Cmp_Ordering_Type.t_ordering
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  function cmp_log (self : self) (_2' : self) : Core_Cmp_Ordering_Type.t_ordering
  val cmp_log (self : self) (_2' : self) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = cmp_log self _2' }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub
  type self
  predicate lt_log (self : self) (o : self)
end
module CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface
  type self
  predicate lt_log (self : self) (o : self)
end
module CreusotContracts_Logic_Ord_OrdLogic_LtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  predicate lt_log (self : self) (o : self) =
    [#"../src/lib.rs" 384 33 384 66] CmpLog0.cmp_log self o = Core_Cmp_Ordering_Type.C_Less
  val lt_log (self : self) (o : self) : bool
    ensures { result = lt_log self o }
    
end
module Vecmap_Impl0_IsSorted_Stub
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_sorted [#"../src/lib.rs" 60 4 60 30] (self : Vecmap_VecMap_Type.t_vecmap k v)
end
module Vecmap_Impl0_IsSorted_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_sorted [#"../src/lib.rs" 60 4 60 30] (self : Vecmap_VecMap_Type.t_vecmap k v)
end
module Vecmap_Impl0_IsSorted
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use mach.int.Int
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate is_sorted [#"../src/lib.rs" 60 4 60 30] (self : Vecmap_VecMap_Type.t_vecmap k v) =
    [#"../src/lib.rs" 61 8 64 9] forall n : int . forall m : int . m >= 0 /\ n >= 0 /\ m < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ n < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) /\ m < n -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) m) (Seq.get (KeySeq0.key_seq self) n)
  val is_sorted [#"../src/lib.rs" 60 4 60 30] (self : Vecmap_VecMap_Type.t_vecmap k v) : bool
    ensures { result = is_sorted self }
    
end
module Alloc_Vec_Impl0_New_Interface
  type t
  use seq.Seq
  clone Core_Num_Impl12_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val new [@cfg:stackify] (_1' : ()) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    ensures { Seq.length (ShallowModel0.shallow_model result) = 0 }
    
end
module Alloc_Vec_Impl0_New
  type t
  use seq.Seq
  clone Core_Num_Impl12_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val new [@cfg:stackify] (_1' : ()) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    ensures { Seq.length (ShallowModel0.shallow_model result) = 0 }
    
end
module Vecmap_Impl1_New_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  val new [@cfg:stackify] [#"../src/lib.rs" 73 4 73 24] (_1' : ()) : Vecmap_VecMap_Type.t_vecmap k v
end
module Vecmap_Impl1_New
  type k
  type v
  clone Core_Num_Impl12_Max as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Alloc_Vec_Impl0_New_Interface as New0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  let rec cfg new [@cfg:stackify] [#"../src/lib.rs" 73 4 73 24] (_1' : ()) : Vecmap_VecMap_Type.t_vecmap k v
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_VecMap_Type.t_vecmap k v;
  var _1 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  {
    goto BB0
  }
  BB0 {
    _1 <- ([#"../src/lib.rs" 74 18 74 28] New0.new ());
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_VecMap_Type.C_VecMap _1;
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_OccupiedEntry_Type
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  type t_occupiedentry 'k 'v =
    | C_OccupiedEntry (borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)) 'k usize
    
  let function occupiedentry_map (self : t_occupiedentry 'k 'v) : borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_OccupiedEntry a _ _ -> a
      end
  let function occupiedentry_index (self : t_occupiedentry 'k 'v) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_OccupiedEntry _ _ a -> a
      end
  let function occupiedentry_key (self : t_occupiedentry 'k 'v) : 'k = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_OccupiedEntry _ a _ -> a
      end
end
module Vecmap_VacantEntry_Type
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  type t_vacantentry 'k 'v =
    | C_VacantEntry (borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)) 'k usize
    
  let function vacantentry_map (self : t_vacantentry 'k 'v) : borrowed (Vecmap_VecMap_Type.t_vecmap 'k 'v)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VacantEntry a _ _ -> a
      end
  let function vacantentry_index (self : t_vacantentry 'k 'v) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VacantEntry _ _ a -> a
      end
  let function vacantentry_key (self : t_vacantentry 'k 'v) : 'k = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VacantEntry _ a _ -> a
      end
end
module Vecmap_Entry_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  type t_entry 'k 'v =
    | C_Vacant (Vecmap_VacantEntry_Type.t_vacantentry 'k 'v)
    | C_Occupied (Vecmap_OccupiedEntry_Type.t_occupiedentry 'k 'v)
    
  let function occupied_0 (self : t_entry 'k 'v) : Vecmap_OccupiedEntry_Type.t_occupiedentry 'k 'v
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Vacant _ -> any Vecmap_OccupiedEntry_Type.t_occupiedentry 'k 'v
      | C_Occupied a -> a
      end
  let function vacant_0 (self : t_entry 'k 'v) : Vecmap_VacantEntry_Type.t_vacantentry 'k 'v
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Vacant a -> a
      | C_Occupied _ -> any Vecmap_VacantEntry_Type.t_vacantentry 'k 'v
      end
end
module Vecmap_Impl8_Invariant_Stub
  type k
  type v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  predicate invariant' [#"../src/lib.rs" 537 4 537 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
end
module Vecmap_Impl8_Invariant_Interface
  type k
  type v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  predicate invariant' [#"../src/lib.rs" 537 4 537 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v)
end
module Vecmap_Impl8_Invariant
  type k
  type v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  use prelude.Borrow
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  predicate invariant' [#"../src/lib.rs" 537 4 537 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v) =
    [#"../src/lib.rs" 538 8 542 9] IsSorted0.is_sorted ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self))) > UInt64.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index self) /\ Seq.get (KeySeq0.key_seq ( * Vecmap_OccupiedEntry_Type.occupiedentry_map self)) (UInt64.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index self)) = DeepModel0.deep_model (Vecmap_OccupiedEntry_Type.occupiedentry_key self)
  val invariant' [#"../src/lib.rs" 537 4 537 30] (self : Vecmap_OccupiedEntry_Type.t_occupiedentry k v) : bool
    ensures { result = invariant' self }
    
end
module Vecmap_Impl6_Invariant_Stub
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate invariant' [#"../src/lib.rs" 507 4 507 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
end
module Vecmap_Impl6_Invariant_Interface
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate invariant' [#"../src/lib.rs" 507 4 507 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
end
module Vecmap_Impl6_Invariant
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  use prelude.Borrow
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  predicate invariant' [#"../src/lib.rs" 507 4 507 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) =
    [#"../src/lib.rs" 508 8 510 9] IsSorted0.is_sorted ( * Vecmap_VacantEntry_Type.vacantentry_map self) /\ UInt64.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self)))
  val invariant' [#"../src/lib.rs" 507 4 507 30] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = invariant' self }
    
end
module Core_Result_Result_Type
  type t_result 't 'e =
    | C_Ok 't
    | C_Err 'e
    
  let function err_0 (self : t_result 't 'e) : 'e = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Ok _ -> any 'e
      | C_Err a -> a
      end
  let function ok_0 (self : t_result 't 'e) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Ok a -> a
      | C_Err _ -> any 't
      end
end
module CreusotContracts_Model_Impl0_DeepModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_Impl0_DeepModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  function deep_model (self : t) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_Impl0_DeepModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = t,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function deep_model (self : t) : DeepModelTy0.deepModelTy =
    DeepModel0.deep_model self
  val deep_model (self : t) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Logic_Seq_Impl0_Contains_Stub
  type t
  use seq.Seq
  predicate contains (self : Seq.seq t) (e : t)
end
module CreusotContracts_Logic_Seq_Impl0_Contains_Interface
  type t
  use seq.Seq
  predicate contains (self : Seq.seq t) (e : t)
end
module CreusotContracts_Logic_Seq_Impl0_Contains
  type t
  use seq.Seq
  use mach.int.Int
  predicate contains (self : Seq.seq t) (e : t) =
    exists i : int . 0 <= i /\ i < Seq.length self /\ Seq.get self i = e
  val contains (self : Seq.seq t) (e : t) : bool
    ensures { result = contains self e }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub
  type self
  predicate gt_log (self : self) (o : self)
end
module CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface
  type self
  predicate gt_log (self : self) (o : self)
end
module CreusotContracts_Logic_Ord_OrdLogic_GtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  predicate gt_log (self : self) (o : self) =
    [#"../src/lib.rs" 391 35 392 1] CmpLog0.cmp_log self o = Core_Cmp_Ordering_Type.C_Greater
  val gt_log (self : self) (o : self) : bool
    ensures { result = gt_log self o }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl1_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type
  type t
  type a
  use seq.Seq
  type shallowModelTy  =
    Seq.seq t
end
module Alloc_Vec_Impl1_Len_Interface
  type t
  type a
  use mach.int.UInt64
  use seq.Seq
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val len [@cfg:stackify] (self : Alloc_Vec_Vec_Type.t_vec t a) : usize
    ensures { UInt64.to_int result = Seq.length (ShallowModel0.shallow_model self) }
    
end
module Alloc_Vec_Impl1_Len
  type t
  type a
  use mach.int.UInt64
  use seq.Seq
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl1_ShallowModel_Interface as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val len [@cfg:stackify] (self : Alloc_Vec_Vec_Type.t_vec t a) : usize
    ensures { UInt64.to_int result = Seq.length (ShallowModel0.shallow_model self) }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type
  type t
  use seq.Seq
  type shallowModelTy  =
    Seq.seq t
end
module Alloc_Vec_Impl16_Index_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = seq t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val index [@cfg:stackify] (self : Alloc_Vec_Vec_Type.t_vec t a) (index : i) : Output0.output
    requires {InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { HasValue0.has_value index (ShallowModel0.shallow_model self) result }
    
end
module Alloc_Vec_Impl16_Index
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = seq t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface as HasValue0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface as InBounds0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  clone CreusotContracts_Model_Impl1_ShallowModel_Interface as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val index [@cfg:stackify] (self : Alloc_Vec_Vec_Type.t_vec t a) (index : i) : Output0.output
    requires {InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { HasValue0.has_value index (ShallowModel0.shallow_model self) result }
    
end
module Core_Cmp_Ord_Cmp_Interface
  type self
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val cmp [@cfg:stackify] (self : self) (other : self) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = CmpLog0.cmp_log (DeepModel0.deep_model self) (DeepModel0.deep_model other) }
    
end
module Core_Cmp_Ord_Cmp
  type self
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val cmp [@cfg:stackify] (self : self) (other : self) : Core_Cmp_Ordering_Type.t_ordering
    ensures { result = CmpLog0.cmp_log (DeepModel0.deep_model self) (DeepModel0.deep_model other) }
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub
  type self
  predicate le_log (self : self) (o : self)
end
module CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface
  type self
  predicate le_log (self : self) (o : self)
end
module CreusotContracts_Logic_Ord_OrdLogic_LeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  predicate le_log (self : self) (o : self) =
    [#"../src/lib.rs" 380 31 381 26] CmpLog0.cmp_log self o <> Core_Cmp_Ordering_Type.C_Greater
  val le_log (self : self) (o : self) : bool
    ensures { result = le_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = self
  function cmp_le_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = self
  function cmp_le_log (x : self) (y : self) : ()
  axiom cmp_le_log_spec : forall x : self, y : self . [#"../src/lib.rs" 382 3 382 53] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = self
  function cmp_le_log (x : self) (y : self) : ()
  val cmp_le_log (x : self) (y : self) : ()
    ensures { result = cmp_le_log x y }
    
  axiom cmp_le_log_spec : forall x : self, y : self . [#"../src/lib.rs" 382 3 382 53] LeLog0.le_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = self
  function cmp_lt_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = self
  function cmp_lt_log (x : self) (y : self) : ()
  axiom cmp_lt_log_spec : forall x : self, y : self . [#"../src/lib.rs" 384 101 385 42] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = self
  function cmp_lt_log (x : self) (y : self) : ()
  val cmp_lt_log (x : self) (y : self) : ()
    ensures { result = cmp_lt_log x y }
    
  axiom cmp_lt_log_spec : forall x : self, y : self . [#"../src/lib.rs" 384 101 385 42] LtLog0.lt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub
  type self
  predicate ge_log (self : self) (o : self)
end
module CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface
  type self
  predicate ge_log (self : self) (o : self)
end
module CreusotContracts_Logic_Ord_OrdLogic_GeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  predicate ge_log (self : self) (o : self) =
    [#"../src/lib.rs" 386 78 387 16] CmpLog0.cmp_log self o <> Core_Cmp_Ordering_Type.C_Less
  val ge_log (self : self) (o : self) : bool
    ensures { result = ge_log self o }
    
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = self
  function cmp_ge_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = self
  function cmp_ge_log (x : self) (y : self) : ()
  axiom cmp_ge_log_spec : forall x : self, y : self . [#"../src/lib.rs" 387 51 388 31] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = self
  function cmp_ge_log (x : self) (y : self) : ()
  val cmp_ge_log (x : self) (y : self) : ()
    ensures { result = cmp_ge_log x y }
    
  axiom cmp_ge_log_spec : forall x : self, y : self . [#"../src/lib.rs" 387 51 388 31] GeLog0.ge_log x y = (CmpLog0.cmp_log x y <> Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = self
  function cmp_gt_log (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = self
  function cmp_gt_log (x : self) (y : self) : ()
  axiom cmp_gt_log_spec : forall x : self, y : self . [#"../src/lib.rs" 392 36 393 18] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = self
  function cmp_gt_log (x : self) (y : self) : ()
  val cmp_gt_log (x : self) (y : self) : ()
    ensures { result = cmp_gt_log x y }
    
  axiom cmp_gt_log_spec : forall x : self, y : self . [#"../src/lib.rs" 392 36 393 18] GtLog0.gt_log x y = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_Refl_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function refl (x : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function refl (x : self) : ()
  axiom refl_spec : forall x : self . [#"../src/lib.rs" 395 43 395 74] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal
end
module CreusotContracts_Logic_Ord_OrdLogic_Refl
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function refl (x : self) : ()
  val refl (x : self) : ()
    ensures { result = refl x }
    
  axiom refl_spec : forall x : self . [#"../src/lib.rs" 395 43 395 74] CmpLog0.cmp_log x x = Core_Cmp_Ordering_Type.C_Equal
end
module CreusotContracts_Logic_Ord_OrdLogic_Trans_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
  axiom trans_spec : forall x : self, y : self, z : self, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../src/lib.rs" 396 42 396 59] CmpLog0.cmp_log x y = o) -> ([#"../src/lib.rs" 397 5 397 22] CmpLog0.cmp_log y z = o) -> ([#"../src/lib.rs" 398 5 399 15] CmpLog0.cmp_log x z = o)
end
module CreusotContracts_Logic_Ord_OrdLogic_Trans
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
  val trans (x : self) (y : self) (z : self) (o : Core_Cmp_Ordering_Type.t_ordering) : ()
    requires {[#"../src/lib.rs" 396 42 396 59] CmpLog0.cmp_log x y = o}
    requires {[#"../src/lib.rs" 397 5 397 22] CmpLog0.cmp_log y z = o}
    ensures { result = trans x y z o }
    
  axiom trans_spec : forall x : self, y : self, z : self, o : Core_Cmp_Ordering_Type.t_ordering . ([#"../src/lib.rs" 396 42 396 59] CmpLog0.cmp_log x y = o) -> ([#"../src/lib.rs" 397 5 397 22] CmpLog0.cmp_log y z = o) -> ([#"../src/lib.rs" 398 5 399 15] CmpLog0.cmp_log x z = o)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym1 (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym1 (x : self) (y : self) : ()
  axiom antisym1_spec : forall x : self, y : self . ([#"../src/lib.rs" 400 33 404 13] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) -> ([#"../src/lib.rs" 404 30 405 2] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym1
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym1 (x : self) (y : self) : ()
  val antisym1 (x : self) (y : self) : ()
    requires {[#"../src/lib.rs" 400 33 404 13] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less}
    ensures { result = antisym1 x y }
    
  axiom antisym1_spec : forall x : self, y : self . ([#"../src/lib.rs" 400 33 404 13] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Less) -> ([#"../src/lib.rs" 404 30 405 2] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Greater)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym2 (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym2 (x : self) (y : self) : ()
  axiom antisym2_spec : forall x : self, y : self . ([#"../src/lib.rs" 407 5 408 1] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) -> ([#"../src/lib.rs" 411 9 412 4] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_Antisym2
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function antisym2 (x : self) (y : self) : ()
  val antisym2 (x : self) (y : self) : ()
    requires {[#"../src/lib.rs" 407 5 408 1] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater}
    ensures { result = antisym2 x y }
    
  axiom antisym2_spec : forall x : self, y : self . ([#"../src/lib.rs" 407 5 408 1] CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Greater) -> ([#"../src/lib.rs" 411 9 412 4] CmpLog0.cmp_log y x = Core_Cmp_Ordering_Type.C_Less)
end
module CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Stub
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function eq_cmp (x : self) (y : self) : ()
end
module CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function eq_cmp (x : self) (y : self) : ()
  axiom eq_cmp_spec : forall x : self, y : self . [#"../src/lib.rs" 413 7 413 52] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal)
end
module CreusotContracts_Logic_Ord_OrdLogic_EqCmp
  type self
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Stub as CmpLog0 with
    type self = self
  function eq_cmp (x : self) (y : self) : ()
  val eq_cmp (x : self) (y : self) : ()
    ensures { result = eq_cmp x y }
    
  axiom eq_cmp_spec : forall x : self, y : self . [#"../src/lib.rs" 413 7 413 52] (x = y) = (CmpLog0.cmp_log x y = Core_Cmp_Ordering_Type.C_Equal)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use mach.int.UInt64
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    UInt64.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use mach.int.UInt64
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    Seq.get seq (UInt64.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module Core_Slice_Index_Impl2_Output_Type
  type t
  type output  =
    t
end
module Vecmap_Impl1_FindK_Interface
  type k
  type v
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.UInt64
  use seq.Seq
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val find_k [@cfg:stackify] [#"../src/lib.rs" 347 4 347 53] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Result_Result_Type.t_result usize usize
    requires {[#"../src/lib.rs" 333 15 333 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 334 14 337 5] match (result) with
      | Core_Result_Result_Type.C_Ok _ -> Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      | Core_Result_Result_Type.C_Err _ -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      end }
    ensures { [#"../src/lib.rs" 338 4 338 91] forall i : usize . result = Core_Result_Result_Type.C_Ok i -> Seq.get (KeySeq0.key_seq self) (UInt64.to_int i) = DeepModel0.deep_model key }
    ensures { [#"../src/lib.rs" 339 4 340 52] forall j : int . forall i : usize . result = Core_Result_Result_Type.C_Err i -> j >= UInt64.to_int i /\ j < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"../src/lib.rs" 341 4 342 52] forall j : int . forall i : usize . result = Core_Result_Result_Type.C_Err i /\ j >= 0 /\ j < UInt64.to_int i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"../src/lib.rs" 343 14 346 5] match (result) with
      | Core_Result_Result_Type.C_Ok idx -> UInt64.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      | Core_Result_Result_Type.C_Err idx -> UInt64.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      end }
    
end
module Vecmap_Impl1_FindK
  type k
  type v
  use mach.int.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.Int8
  use mach.int.UInt64
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v)
  clone Core_Slice_Index_Impl2_Output_Type as Output0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = k
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone Core_Cmp_Ord_Cmp_Interface as Cmp0 with
    type self = k,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = (k, v)
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = Output0.output
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Core_Result_Result_Type as Core_Result_Result_Type
  let rec cfg find_k [@cfg:stackify] [#"../src/lib.rs" 347 4 347 53] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Result_Result_Type.t_result usize usize
    requires {[#"../src/lib.rs" 333 15 333 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 334 14 337 5] match (result) with
      | Core_Result_Result_Type.C_Ok _ -> Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      | Core_Result_Result_Type.C_Err _ -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key)
      end }
    ensures { [#"../src/lib.rs" 338 4 338 91] forall i : usize . result = Core_Result_Result_Type.C_Ok i -> Seq.get (KeySeq0.key_seq self) (UInt64.to_int i) = DeepModel0.deep_model key }
    ensures { [#"../src/lib.rs" 339 4 340 52] forall j : int . forall i : usize . result = Core_Result_Result_Type.C_Err i -> j >= UInt64.to_int i /\ j < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"../src/lib.rs" 341 4 342 52] forall j : int . forall i : usize . result = Core_Result_Result_Type.C_Err i /\ j >= 0 /\ j < UInt64.to_int i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model key) }
    ensures { [#"../src/lib.rs" 343 14 346 5] match (result) with
      | Core_Result_Result_Type.C_Ok idx -> UInt64.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      | Core_Result_Result_Type.C_Err idx -> UInt64.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self))
      end }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Result_Result_Type.t_result usize usize;
  var self_1 : Vecmap_VecMap_Type.t_vecmap k v;
  var key_2 : k;
  var size_9 : usize;
  var _10 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var left_11 : usize;
  var right_12 : usize;
  var mid_13 : usize;
  var _14 : ();
  var _22 : ();
  var _23 : bool;
  var _24 : usize;
  var _25 : usize;
  var _26 : usize;
  var _27 : usize;
  var _28 : usize;
  var _29 : bool;
  var cmp_30 : Core_Cmp_Ordering_Type.t_ordering;
  var _31 : k;
  var _32 : (k, v);
  var _33 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _34 : usize;
  var _35 : k;
  var _36 : ();
  var _37 : int8;
  var _38 : usize;
  var _39 : usize;
  var _40 : ();
  var _41 : usize;
  var _42 : usize;
  var _43 : usize;
  var _44 : ();
  var _45 : ();
  var _46 : ();
  var _47 : usize;
  {
    self_1 <- self;
    key_2 <- key;
    goto BB0
  }
  BB0 {
    _10 <- Vecmap_VecMap_Type.vecmap_v self_1;
    size_9 <- ([#"../src/lib.rs" 348 23 348 35] Len0.len _10);
    goto BB1
  }
  BB1 {
    left_11 <- ([#"../src/lib.rs" 349 23 349 24] (0 : usize));
    right_12 <- size_9;
    goto BB2
  }
  BB2 {
    invariant size_bounds { [#"../src/lib.rs" 353 33 353 71] UInt64.to_int size_9 >= 0 /\ UInt64.to_int size_9 <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self_1)) };
    invariant left_bounds { [#"../src/lib.rs" 354 33 354 71] UInt64.to_int left_11 >= 0 /\ UInt64.to_int left_11 <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self_1)) };
    invariant right_bounds { [#"../src/lib.rs" 355 34 355 74] UInt64.to_int right_12 >= 0 /\ UInt64.to_int right_12 <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self_1)) };
    invariant mid_bounds { [#"../src/lib.rs" 353 8 353 73] UInt64.to_int left_11 < UInt64.to_int right_12 -> UInt64.to_int left_11 + div (UInt64.to_int size_9) 2 < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self_1)) };
    invariant right_gt_mid { [#"../src/lib.rs" 353 8 353 73] UInt64.to_int left_11 < UInt64.to_int right_12 -> UInt64.to_int right_12 > UInt64.to_int left_11 + div (UInt64.to_int size_9) 2 };
    invariant right_geq_key { [#"../src/lib.rs" 353 8 353 73] forall i : int . i >= UInt64.to_int right_12 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self_1)) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq self_1) i) (DeepModel0.deep_model key_2) };
    invariant left_lt_key { [#"../src/lib.rs" 353 8 353 73] forall i : int . i >= 0 /\ i < UInt64.to_int left_11 -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self_1) i) (DeepModel0.deep_model key_2) };
    _24 <- left_11;
    _25 <- right_12;
    _23 <- ([#"../src/lib.rs" 362 14 362 26] _24 < _25);
    switch (_23)
      | False -> goto BB12
      | True -> goto BB3
      end
  }
  BB3 {
    _26 <- left_11;
    _28 <- size_9;
    _29 <- ([#"../src/lib.rs" 363 25 363 33] ([#"../src/lib.rs" 363 32 363 33] (2 : usize)) = ([#"../src/lib.rs" 363 25 363 33] (0 : usize)));
    assert { [#"../src/lib.rs" 363 25 363 33] not _29 };
    goto BB4
  }
  BB4 {
    _27 <- ([#"../src/lib.rs" 363 25 363 33] _28 / ([#"../src/lib.rs" 363 32 363 33] (2 : usize)));
    mid_13 <- ([#"../src/lib.rs" 363 12 363 33] _26 + _27);
    _33 <- Vecmap_VecMap_Type.vecmap_v self_1;
    _34 <- mid_13;
    _32 <- ([#"../src/lib.rs" 365 22 365 33] Index0.index _33 _34);
    goto BB5
  }
  BB5 {
    _31 <- (let (a, _) = _32 in a);
    assume { Resolve0.resolve _32 };
    _35 <- key_2;
    cmp_30 <- ([#"../src/lib.rs" 365 22 365 44] Cmp0.cmp _31 _35);
    goto BB6
  }
  BB6 {
    switch (cmp_30)
      | Core_Cmp_Ordering_Type.C_Less -> goto BB9
      | Core_Cmp_Ordering_Type.C_Equal -> goto BB7
      | Core_Cmp_Ordering_Type.C_Greater -> goto BB10
      end
  }
  BB7 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve key_2 };
    _41 <- mid_13;
    _0 <- Core_Result_Result_Type.C_Ok _41;
    goto BB13
  }
  BB8 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve key_2 };
    absurd
  }
  BB9 {
    _38 <- mid_13;
    left_11 <- ([#"../src/lib.rs" 368 34 368 48] _38 + ([#"../src/lib.rs" 368 47 368 48] (1 : usize)));
    _36 <- ();
    goto BB11
  }
  BB10 {
    _39 <- mid_13;
    right_12 <- _39;
    _39 <- any usize;
    _36 <- ();
    goto BB11
  }
  BB11 {
    _42 <- right_12;
    _43 <- left_11;
    size_9 <- ([#"../src/lib.rs" 373 12 373 31] _42 - _43);
    _22 <- ();
    goto BB2
  }
  BB12 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve key_2 };
    _14 <- ();
    _47 <- left_11;
    _0 <- Core_Result_Result_Type.C_Err _47;
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
     ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module Vecmap_Impl1_Entry_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl6_Invariant_Stub as Invariant1 with
    type k = k,
    type v = v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl8_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val entry [@cfg:stackify] [#"../src/lib.rs" 82 4 82 50] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"../src/lib.rs" 79 15 79 31] IsSorted0.is_sorted ( * self)}
    ensures { [#"../src/lib.rs" 80 4 80 75] forall e : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . result = Vecmap_Entry_Type.C_Occupied e -> Invariant0.invariant' e }
    ensures { [#"../src/lib.rs" 81 4 81 73] forall e : Vecmap_VacantEntry_Type.t_vacantentry k v . result = Vecmap_Entry_Type.C_Vacant e -> Invariant1.invariant' e }
    
end
module Vecmap_Impl1_Entry
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use prelude.IntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = k
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function DeepModel1.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl6_Invariant as Invariant1 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl8_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    val Max0.mAX' = Max0.mAX',
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  let rec cfg entry [@cfg:stackify] [#"../src/lib.rs" 82 4 82 50] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"../src/lib.rs" 79 15 79 31] IsSorted0.is_sorted ( * self)}
    ensures { [#"../src/lib.rs" 80 4 80 75] forall e : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . result = Vecmap_Entry_Type.C_Occupied e -> Invariant0.invariant' e }
    ensures { [#"../src/lib.rs" 81 4 81 73] forall e : Vecmap_VacantEntry_Type.t_vacantentry k v . result = Vecmap_Entry_Type.C_Vacant e -> Invariant1.invariant' e }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_Entry_Type.t_entry k v;
  var self_1 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var key_2 : k;
  var _6 : Core_Result_Result_Type.t_result usize usize;
  var _7 : Vecmap_VecMap_Type.t_vecmap k v;
  var _8 : k;
  var _9 : k;
  var _10 : isize;
  var index_11 : usize;
  var _12 : Vecmap_OccupiedEntry_Type.t_occupiedentry k v;
  var _13 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var _14 : usize;
  var _15 : k;
  var index_16 : usize;
  var _17 : Vecmap_VacantEntry_Type.t_vacantentry k v;
  var _18 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var _19 : usize;
  var _20 : k;
  {
    self_1 <- self;
    key_2 <- key;
    goto BB0
  }
  BB0 {
    _7 <-  * self_1;
    _9 <- key_2;
    _8 <- _9;
    assume { Resolve0.resolve _9 };
    _6 <- ([#"../src/lib.rs" 83 14 83 31] FindK0.find_k _7 _8);
    goto BB1
  }
  BB1 {
    switch (_6)
      | Core_Result_Result_Type.C_Ok _ -> goto BB4
      | Core_Result_Result_Type.C_Err _ -> goto BB2
      end
  }
  BB2 {
    index_16 <- Core_Result_Result_Type.err_0 _6;
    _18 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _18) };
    assume { Resolve1.resolve self_1 };
    _19 <- index_16;
    assume { Resolve2.resolve _20 };
    _20 <- key_2;
    key_2 <- any k;
    _17 <- Vecmap_VacantEntry_Type.C_VacantEntry _18 _20 _19;
    goto BB7
  }
  BB3 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve key_2 };
    absurd
  }
  BB4 {
    index_11 <- Core_Result_Result_Type.ok_0 _6;
    _13 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _13) };
    assume { Resolve1.resolve self_1 };
    _14 <- index_11;
    assume { Resolve2.resolve _15 };
    _15 <- key_2;
    key_2 <- any k;
    _12 <- Vecmap_OccupiedEntry_Type.C_OccupiedEntry _13 _15 _14;
    goto BB5
  }
  BB5 {
    _0 <- Vecmap_Entry_Type.C_Occupied _12;
    goto BB6
  }
  BB6 {
    goto BB9
  }
  BB7 {
    _0 <- Vecmap_Entry_Type.C_Vacant _17;
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    return _0
  }
  
end
module Vecmap_KeyRef_Type
  use mach.int.Int
  use prelude.UIntSize
  type t_keyref 'k =
    | C_KeyRef 'k usize
    
  let function keyref_key (self : t_keyref 'k) : 'k = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_KeyRef a _ -> a
      end
  let function keyref_min_idx (self : t_keyref 'k) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_KeyRef _ a -> a
      end
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module CreusotContracts_Logic_Seq_Impl0_Get_Stub
  type t
  use seq.Seq
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
end
module CreusotContracts_Logic_Seq_Impl0_Get_Interface
  type t
  use seq.Seq
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
end
module CreusotContracts_Logic_Seq_Impl0_Get
  type t
  use seq.Seq
  use mach.int.Int
  use Core_Option_Option_Type as Core_Option_Option_Type
  function get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t =
    if ix < Seq.length self then Core_Option_Option_Type.C_Some (Seq.get self ix) else Core_Option_Option_Type.C_None
  val get (self : Seq.seq t) (ix : int) : Core_Option_Option_Type.t_option t
    ensures { result = get self ix }
    
end
module Vecmap_Impl1_IsValidKeyrefLg_Stub
  type k
  type v
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  predicate is_valid_keyref_lg [#"../src/lib.rs" 284 4 284 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    
end
module Vecmap_Impl1_IsValidKeyrefLg_Interface
  type k
  type v
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  predicate is_valid_keyref_lg [#"../src/lib.rs" 284 4 284 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    
  axiom is_valid_keyref_lg_spec : forall self : Vecmap_VecMap_Type.t_vecmap k v, key : Vecmap_KeyRef_Type.t_keyref k . ([#"../src/lib.rs" 283 15 283 31] IsSorted0.is_sorted self) -> true
end
module Vecmap_Impl1_IsValidKeyrefLg
  type k
  type v
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  use mach.int.UInt64
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get_Stub as Get0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  predicate is_valid_keyref_lg [#"../src/lib.rs" 284 4 284 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    
   =
    [#"../src/lib.rs" 286 12 291 13] match (Get0.get (KeySeq0.key_seq self) (UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx key))) with
      | Core_Option_Option_Type.C_Some k -> LeLog0.le_log k (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))
      | _ -> false
      end
  val is_valid_keyref_lg [#"../src/lib.rs" 284 4 284 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    requires {[#"../src/lib.rs" 283 15 283 31] IsSorted0.is_sorted self}
    ensures { result = is_valid_keyref_lg self key }
    
  axiom is_valid_keyref_lg_spec : forall self : Vecmap_VecMap_Type.t_vecmap k v, key : Vecmap_KeyRef_Type.t_keyref k . ([#"../src/lib.rs" 283 15 283 31] IsSorted0.is_sorted self) -> true
end
module Vecmap_Impl1_IsValidKeyrefLg_Impl
  type k
  type v
  use mach.int.UInt64
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec ghost predicate is_valid_keyref_lg [#"../src/lib.rs" 284 4 284 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k)
    requires {[#"../src/lib.rs" 283 15 283 31] IsSorted0.is_sorted self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../src/lib.rs" 286 12 291 13] match (let a' = KeySeq0.key_seq self in Get0.get a' (UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx key))) with
      | Core_Option_Option_Type.C_Some k -> let b' = DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key) in LeLog0.le_log k b'
      | _ -> false
      end
end
module Vecmap_Impl10_DeepModel_Stub
  type k
  use mach.int.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  function deep_model [#"../src/lib.rs" 580 4 580 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    
end
module Vecmap_Impl10_DeepModel_Interface
  type k
  use mach.int.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  function deep_model [#"../src/lib.rs" 580 4 580 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    
end
module Vecmap_Impl10_DeepModel
  type k
  use mach.int.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use mach.int.UInt64
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function deep_model [#"../src/lib.rs" 580 4 580 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    
   =
    [#"../src/lib.rs" 581 19 581 57] (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key self), UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx self))
  val deep_model [#"../src/lib.rs" 580 4 580 44] (self : Vecmap_KeyRef_Type.t_keyref k) : (DeepModelTy0.deepModelTy, int)
    ensures { result = deep_model self }
    
end
module Vecmap_Impl10_DeepModelTy_Type
  type k
  use mach.int.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  type deepModelTy  =
    (DeepModelTy0.deepModelTy, int)
end
module CreusotContracts_Model_Impl0_DeepModelTy_Type
  type t
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = t
  type deepModelTy  =
    DeepModelTy0.deepModelTy
end
module Vecmap_Impl12_AsRef_Interface
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy2 with
    type self = k
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy2.deepModelTy
  clone Vecmap_Impl10_DeepModelTy_Type as DeepModelTy0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy2.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val as_ref [@cfg:stackify] [#"../src/lib.rs" 598 4 598 38] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    ensures { [#"../src/lib.rs" 597 14 597 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    
end
module Vecmap_Impl12_AsRef
  type k
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy2 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel4 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy2.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel3 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy2.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy2.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl10_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy2.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Vecmap_Impl10_DeepModelTy_Type as DeepModelTy0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy2.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl10_DeepModel as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel2.deep_model
  let rec cfg as_ref [@cfg:stackify] [#"../src/lib.rs" 598 4 598 38] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    ensures { [#"../src/lib.rs" 597 14 597 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self_1 : Vecmap_KeyRef_Type.t_keyref k;
  var _3 : usize;
  var _4 : k;
  var _5 : k;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _3 <- Vecmap_KeyRef_Type.keyref_min_idx self_1;
    _5 <- Vecmap_KeyRef_Type.keyref_key self_1;
    assume { Resolve0.resolve self_1 };
    _4 <- _5;
    assume { Resolve1.resolve _5 };
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _4 _3;
    return _0
  }
  
end
module Vecmap_Impl13_ToOwned_Stub
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = k
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function to_owned [#"../src/lib.rs" 609 4 609 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
end
module Vecmap_Impl13_ToOwned_Interface
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = k
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function to_owned [#"../src/lib.rs" 609 4 609 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
  axiom to_owned_spec : forall self : Vecmap_KeyRef_Type.t_keyref k . [#"../src/lib.rs" 608 14 608 54] DeepModel0.deep_model self = DeepModel1.deep_model (to_owned self)
end
module Vecmap_Impl13_ToOwned
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = k
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  function to_owned [#"../src/lib.rs" 609 4 609 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
   =
    [#"../src/lib.rs" 610 8 613 9] Vecmap_KeyRef_Type.C_KeyRef (Vecmap_KeyRef_Type.keyref_key self) (Vecmap_KeyRef_Type.keyref_min_idx self)
  val to_owned [#"../src/lib.rs" 609 4 609 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    ensures { result = to_owned self }
    
  axiom to_owned_spec : forall self : Vecmap_KeyRef_Type.t_keyref k . [#"../src/lib.rs" 608 14 608 54] DeepModel0.deep_model self = DeepModel1.deep_model (to_owned self)
end
module Vecmap_Impl13_ToOwned_Impl
  type k
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel3 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel2 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl10_DeepModel as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone Vecmap_Impl10_DeepModel as DeepModel0 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel2.deep_model
  let rec ghost function to_owned [#"../src/lib.rs" 609 4 609 34] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    ensures { [#"../src/lib.rs" 608 14 608 54] DeepModel0.deep_model self = DeepModel1.deep_model result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../src/lib.rs" 610 8 613 9] Vecmap_KeyRef_Type.C_KeyRef (Vecmap_KeyRef_Type.keyref_key self) (Vecmap_KeyRef_Type.keyref_min_idx self)
end
module Alloc_Vec_Impl10_Deref_Interface
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = t,
    type a = a
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val deref [@cfg:stackify] (self : Alloc_Vec_Vec_Type.t_vec t a) : seq t
    ensures { ShallowModel0.shallow_model result = ShallowModel1.shallow_model self }
    
end
module Alloc_Vec_Impl10_Deref
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = t,
    type a = a
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl1_ShallowModel_Interface as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  clone CreusotContracts_Model_Impl1_ShallowModel_Interface as ShallowModel0 with
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val deref [@cfg:stackify] (self : Alloc_Vec_Vec_Type.t_vec t a) : seq t
    ensures { ShallowModel0.shallow_model result = ShallowModel1.shallow_model self }
    
end
module Core_Slice_Impl0_Get_Interface
  type t
  type i
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = seq t
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    type Output0.output = Output0.output
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val get [@cfg:stackify] (self : seq t) (index : i) : Core_Option_Option_Type.t_option Output0.output
    ensures { InBounds0.in_bounds index (ShallowModel0.shallow_model self) -> (exists r : Output0.output . result = Core_Option_Option_Type.C_Some r /\ HasValue0.has_value index (ShallowModel0.shallow_model self) r) }
    ensures { InBounds0.in_bounds index (ShallowModel0.shallow_model self) \/ result = Core_Option_Option_Type.C_None }
    
end
module Core_Slice_Impl0_Get
  type t
  type i
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = seq t
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface as HasValue0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    type Output0.output = Output0.output
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface as InBounds0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  clone CreusotContracts_Model_Impl1_ShallowModel_Interface as ShallowModel0 with
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val get [@cfg:stackify] (self : seq t) (index : i) : Core_Option_Option_Type.t_option Output0.output
    ensures { InBounds0.in_bounds index (ShallowModel0.shallow_model self) -> (exists r : Output0.output . result = Core_Option_Option_Type.C_Some r /\ HasValue0.has_value index (ShallowModel0.shallow_model self) r) }
    ensures { InBounds0.in_bounds index (ShallowModel0.shallow_model self) \/ result = Core_Option_Option_Type.C_None }
    
end
module Core_Cmp_Impls_Impl10_Le_Interface
  type a
  type b
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel1 with
    type t = b,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = a,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val le [@cfg:stackify] (self : a) (other : b) : bool
    ensures { result = LeLog0.le_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    
end
module Core_Cmp_Impls_Impl10_Le
  type a
  type b
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Interface as DeepModel1 with
    type t = b,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Interface as DeepModel0 with
    type t = a,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val le [@cfg:stackify] (self : a) (other : b) : bool
    ensures { result = LeLog0.le_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub
  type t
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Slice
  clone Core_Num_Impl12_Max_Stub as Max0
  function shallow_model (self : seq t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface
  type t
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Slice
  clone Core_Num_Impl12_Max_Stub as Max0
  function shallow_model (self : seq t) : Seq.seq t
  axiom shallow_model_spec : forall self : seq t . shallow_model self = Slice.id self && Seq.length (shallow_model self) <= UInt64.to_int Max0.mAX'
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel
  type t
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Slice
  clone Core_Num_Impl12_Max_Stub as Max0
  function shallow_model (self : seq t) : Seq.seq t
  val shallow_model (self : seq t) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : seq t . shallow_model self = Slice.id self && Seq.length (shallow_model self) <= UInt64.to_int Max0.mAX'
end
module Vecmap_Impl1_IsValidKeyref_Interface
  type k
  type v
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy1 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel3 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone Vecmap_Impl10_DeepModel_Stub as DeepModel1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy1.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  clone Vecmap_Impl1_IsValidKeyrefLg_Stub as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    axiom .
  clone Vecmap_Impl13_ToOwned_Stub as ToOwned0 with
    type k = k,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    type DeepModelTy1.deepModelTy = DeepModelTy1.deepModelTy,
    axiom .
  val is_valid_keyref [@cfg:stackify] [#"../src/lib.rs" 275 4 275 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    requires {[#"../src/lib.rs" 270 15 270 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 271 14 271 66] result = IsValidKeyrefLg0.is_valid_keyref_lg self (ToOwned0.to_owned key) }
    ensures { [#"../src/lib.rs" 272 4 272 57] result -> UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) }
    ensures { [#"../src/lib.rs" 273 4 274 57] result -> (forall i : int . i >= 0 /\ i <= UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    
end
module Vecmap_Impl1_IsValidKeyref
  type k
  type v
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use mach.int.Int
  use prelude.UIntSize
  use prelude.IntSize
  use mach.int.UInt64
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel3 with
    type t = (k, v),
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel4 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone Core_Slice_Index_Impl2_Output_Type as Output0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v)
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = seq (k, v),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get1 with
    type t = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl10_DeepModel as DeepModel3 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl10_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone Core_Cmp_Impls_Impl10_Le_Interface as Le0 with
    type a = k,
    type b = k,
    function DeepModel0.deep_model = DeepModel4.deep_model,
    function DeepModel1.deep_model = DeepModel4.deep_model,
    predicate LeLog0.le_log = LeLog0.le_log,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = (k, v),
    type i = usize,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = Output0.output,
    predicate HasValue0.has_value = HasValue0.has_value
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = seq (k, v)
  clone Alloc_Vec_Impl10_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_IsValidKeyrefLg as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate LeLog0.le_log = LeLog0.le_log,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function Get0.get = Get1.get,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl13_ToOwned as ToOwned0 with
    type k = k,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel3.deep_model,
    type DeepModelTy1.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  let rec cfg is_valid_keyref [@cfg:stackify] [#"../src/lib.rs" 275 4 275 55] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : bool
    requires {[#"../src/lib.rs" 270 15 270 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 271 14 271 66] result = IsValidKeyrefLg0.is_valid_keyref_lg self (ToOwned0.to_owned key) }
    ensures { [#"../src/lib.rs" 272 4 272 57] result -> UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) }
    ensures { [#"../src/lib.rs" 273 4 274 57] result -> (forall i : int . i >= 0 /\ i <= UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx key) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : Vecmap_VecMap_Type.t_vecmap k v;
  var key_2 : Vecmap_KeyRef_Type.t_keyref k;
  var _7 : Core_Option_Option_Type.t_option (k, v);
  var _8 : seq (k, v);
  var _9 : seq (k, v);
  var _10 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _11 : usize;
  var _12 : isize;
  var k_13 : k;
  var _14 : k;
  var _15 : k;
  var _16 : k;
  {
    self_1 <- self;
    key_2 <- key;
    goto BB0
  }
  BB0 {
    _10 <- Vecmap_VecMap_Type.vecmap_v self_1;
    assume { Resolve0.resolve self_1 };
    _9 <- ([#"../src/lib.rs" 276 14 276 37] Deref0.deref _10);
    goto BB1
  }
  BB1 {
    _8 <- _9;
    assume { Resolve1.resolve _9 };
    _11 <- Vecmap_KeyRef_Type.keyref_min_idx key_2;
    _7 <- ([#"../src/lib.rs" 276 14 276 37] Get0.get _8 _11);
    goto BB2
  }
  BB2 {
    switch (_7)
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      | _ -> goto BB3
      end
  }
  BB3 {
    assume { Resolve2.resolve key_2 };
    assume { Resolve3.resolve _7 };
    _0 <- ([#"../src/lib.rs" 278 17 278 22] false);
    goto BB6
  }
  BB4 {
    k_13 <- (let (a, _) = Core_Option_Option_Type.some_0 _7 in a);
    assume { Resolve3.resolve _7 };
    _14 <- k_13;
    assume { Resolve4.resolve k_13 };
    _16 <- Vecmap_KeyRef_Type.keyref_key key_2;
    assume { Resolve2.resolve key_2 };
    _15 <- _16;
    assume { Resolve4.resolve _16 };
    _0 <- ([#"../src/lib.rs" 277 28 277 40] Le0.le _14 _15);
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Core_Ops_Range_Range_Type
  type t_range 'idx =
    | C_Range 'idx 'idx
    
  let function range_end (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range _ a -> a
      end
  let function range_start (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range a _ -> a
      end
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub
  type self
  predicate into_iter_pre (self : self)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Interface
  type self
  predicate into_iter_pre (self : self)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre
  type self
  predicate into_iter_pre (self : self) =
    true
  val into_iter_pre (self : self) : bool
    ensures { result = into_iter_pre self }
    
end
module Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type
  type self
  type intoIter
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Interface
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
  val into_iter_post (self : self) (res : IntoIter0.intoIter) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Invariant_Invariant_Invariant_Stub
  type self
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant_Interface
  type self
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant
  type self
  predicate invariant' (self : self)
  val invariant' (self : self) : bool
    ensures { result = invariant' self }
    
end
module Core_Iter_Traits_Collect_Impl0_IntoIter_Type
  type i
  type intoIter  =
    i
end
module Core_Iter_Traits_Collect_Impl0_IntoIter_Interface
  type i
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Type as IntoIter0 with
    type i = i
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub as IntoIterPost0 with
    type self = i,
    type IntoIter0.intoIter = IntoIter0.intoIter
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub as IntoIterPre0 with
    type self = i
  val into_iter [@cfg:stackify] (self : i) : i
    requires {IntoIterPre0.into_iter_pre self}
    ensures { IntoIterPost0.into_iter_post self result }
    ensures { Invariant0.invariant' result }
    
end
module Core_Iter_Traits_Collect_Impl0_IntoIter
  type i
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Type as IntoIter0 with
    type i = i
  clone CreusotContracts_Invariant_Invariant_Invariant_Interface as Invariant0 with
    type self = i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Interface as IntoIterPost0 with
    type self = i,
    type IntoIter0.intoIter = IntoIter0.intoIter
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Interface as IntoIterPre0 with
    type self = i
  val into_iter [@cfg:stackify] (self : i) : i
    requires {IntoIterPre0.into_iter_pre self}
    ensures { IntoIterPost0.into_iter_post self result }
    ensures { Invariant0.invariant' result }
    
end
module CreusotContracts_Std1_Ops_Impl3_Invariant_Stub
  type idx
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate invariant' (self : Core_Ops_Range_Range_Type.t_range idx)
end
module CreusotContracts_Std1_Ops_Impl3_Invariant_Interface
  type idx
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate invariant' (self : Core_Ops_Range_Range_Type.t_range idx)
end
module CreusotContracts_Std1_Ops_Impl3_Invariant
  type idx
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate invariant' (self : Core_Ops_Range_Range_Type.t_range idx) =
    true
  val invariant' (self : Core_Ops_Range_Range_Type.t_range idx) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Stub
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Interface
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
end
module CreusotContracts_Std1_Iter_Iterator_Completed
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
  val completed (self : borrowed self) : bool
    ensures { result = completed self }
    
end
module Core_Iter_Traits_Iterator_Iterator_Item_Type
  type self
  type item
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Stub
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_3' : self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Interface
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_3' : self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_3' : self)
  val produces (self : self) (visited : Seq.seq Item0.item) (_3' : self) : bool
    ensures { result = produces self visited _3' }
    
end
module Core_Iter_Range_Impl3_Item_Type
  type a
  type item  =
    a
end
module Core_Iter_Range_Impl3_Next_Interface
  type a
  use prelude.Borrow
  use seq.Seq
  clone Core_Iter_Range_Impl3_Item_Type as Item1 with
    type a = a
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces0 with
    type self = Core_Ops_Range_Range_Type.t_range a,
    type Item0.item = Item1.item
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone CreusotContracts_Std1_Ops_Impl3_Invariant_Stub as Invariant0 with
    type idx = a
  val next [@cfg:stackify] (self : borrowed (Core_Ops_Range_Range_Type.t_range a)) : Core_Option_Option_Type.t_option a
    requires {Invariant0.invariant' ( * self)}
    ensures { Invariant0.invariant' ( ^ self) }
    ensures { match (result) with
      | Core_Option_Option_Type.C_None -> Completed0.completed self
      | Core_Option_Option_Type.C_Some v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self)
      end }
    
end
module Core_Iter_Range_Impl3_Next
  type a
  use prelude.Borrow
  use seq.Seq
  clone Core_Iter_Range_Impl3_Item_Type as Item1 with
    type a = a
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Interface as Produces0 with
    type self = Core_Ops_Range_Range_Type.t_range a,
    type Item0.item = Item1.item
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Interface as Completed0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone CreusotContracts_Std1_Ops_Impl3_Invariant_Interface as Invariant0 with
    type idx = a
  val next [@cfg:stackify] (self : borrowed (Core_Ops_Range_Range_Type.t_range a)) : Core_Option_Option_Type.t_option a
    requires {Invariant0.invariant' ( * self)}
    ensures { Invariant0.invariant' ( ^ self) }
    ensures { match (result) with
      | Core_Option_Option_Type.C_None -> Completed0.completed self
      | Core_Option_Option_Type.C_Some v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self)
      end }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  use mach.int.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
   =
    Core_Ops_Range_Range_Type.range_end self = Core_Ops_Range_Range_Type.range_end o /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) /\ (Seq.length visited > 0 -> DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end o)) /\ Seq.length visited = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) - DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) /\ (forall i : int . 0 <= i /\ i < Seq.length visited -> DeepModel0.deep_model (Seq.get visited i) = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) + i)
  val produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx) : bool
    ensures { result = produces self visited o }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Stub
  type i
  predicate into_iter_pre (self : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Interface
  type i
  predicate into_iter_pre (self : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre
  type i
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = i
  predicate into_iter_pre (self : i) =
    Invariant0.invariant' self
  val into_iter_pre (self : i) : bool
    ensures { result = into_iter_pre self }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Stub
  type i
  predicate into_iter_post (self : i) (res : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Interface
  type i
  predicate into_iter_post (self : i) (res : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost
  type i
  predicate into_iter_post (self : i) (res : i) =
    self = res
  val into_iter_post (self : i) (res : i) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Std1_Ops_Impl3_Invariant_Stub as Invariant0 with
    type idx = idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Std1_Ops_Impl3_Invariant_Stub as Invariant0 with
    type idx = idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . Invariant0.invariant' a -> Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Std1_Ops_Impl3_Invariant_Stub as Invariant0 with
    type idx = idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : () =
    ()
  val produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {Invariant0.invariant' a}
    ensures { result = produces_refl a }
    
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . Invariant0.invariant' a -> Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Std1_Ops_Impl3_Invariant_Stub as Invariant0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Std1_Ops_Impl3_Invariant_Stub as Invariant0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . Invariant0.invariant' a -> Invariant0.invariant' b -> Invariant0.invariant' c -> Produces0.produces a ab b -> Produces0.produces b bc c -> Produces0.produces a (Seq.(++) ab bc) c
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  clone CreusotContracts_Std1_Ops_Impl3_Invariant_Stub as Invariant0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
   =
    ()
  val produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {Invariant0.invariant' a}
    requires {Invariant0.invariant' b}
    requires {Invariant0.invariant' c}
    requires {Produces0.produces a ab b}
    requires {Produces0.produces b bc c}
    ensures { result = produces_trans a ab b bc c }
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . Invariant0.invariant' a -> Invariant0.invariant' b -> Invariant0.invariant' c -> Produces0.produces a ab b -> Produces0.produces b bc c -> Produces0.produces a (Seq.(++) ab bc) c
end
module CreusotContracts_Logic_Int_Impl18_DeepModel_Stub
  use mach.int.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
end
module CreusotContracts_Logic_Int_Impl18_DeepModel_Interface
  use mach.int.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
end
module CreusotContracts_Logic_Int_Impl18_DeepModel
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.UInt64
  function deep_model (self : usize) : int =
    [#"../src/lib.rs" 319 31 320 0] UInt64.to_int self
  val deep_model (self : usize) : int
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Stub
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Interface
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  use mach.int.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) =
    Resolve0.resolve self /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start ( * self)) >= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end ( * self))
  val completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) : bool
    ensures { result = completed self }
    
end
module Vecmap_Impl1_EntryFromRef_Interface
  type k
  type v
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl6_Invariant_Stub as Invariant1 with
    type k = k,
    type v = v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl8_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  clone Vecmap_Impl1_IsValidKeyrefLg_Stub as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    axiom .
  val entry_from_ref [@cfg:stackify] [#"../src/lib.rs" 111 4 111 80] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key_hint : Vecmap_KeyRef_Type.t_keyref k) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"../src/lib.rs" 106 15 106 31] IsSorted0.is_sorted ( * self)}
    requires {[#"../src/lib.rs" 107 15 107 48] IsValidKeyrefLg0.is_valid_keyref_lg ( * self) key_hint}
    requires {[#"../src/lib.rs" 108 15 108 60] LeLog0.le_log (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key_hint)) (DeepModel0.deep_model key)}
    ensures { [#"../src/lib.rs" 109 4 109 75] forall e : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . result = Vecmap_Entry_Type.C_Occupied e -> Invariant0.invariant' e }
    ensures { [#"../src/lib.rs" 110 4 110 73] forall e : Vecmap_VacantEntry_Type.t_vacantentry k v . result = Vecmap_Entry_Type.C_Vacant e -> Invariant1.invariant' e }
    
end
module Vecmap_Impl1_EntryFromRef
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.IntSize
  use prelude.Int8
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v)
  clone Core_Slice_Index_Impl2_Output_Type as Output0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Logic_Int_Impl18_DeepModel as DeepModel5
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve3.resolve,
    function DeepModel0.deep_model = DeepModel5.deep_model
  clone Core_Iter_Range_Impl3_Item_Type as Item0 with
    type a = usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel5.deep_model
  clone CreusotContracts_Std1_Ops_Impl3_Invariant as Invariant2 with
    type idx = usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans as ProducesTrans0 with
    type idx = usize,
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl as ProducesRefl0 with
    type idx = usize,
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Type as IntoIter1 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant2.invariant'
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl10_DeepModel as DeepModel4 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel3 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy2 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl10_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy2.deepModelTy,
    function DeepModel0.deep_model = DeepModel3.deep_model
  clone Vecmap_Impl13_ToOwned as ToOwned0 with
    type k = k,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel4.deep_model,
    type DeepModelTy1.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone Vecmap_Impl10_DeepModelTy_Type as DeepModelTy1 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel1 with
    type t = Vecmap_KeyRef_Type.t_keyref k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get0 with
    type t = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Core_Cmp_Ord_Cmp_Interface as Cmp0 with
    type self = k,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve7 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = (k, v)
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = Output0.output
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    predicate Invariant0.invariant' = Invariant2.invariant',
    type Item0.item = Item0.item,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post,
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_IsValidKeyrefLg as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate LeLog0.le_log = LeLog0.le_log,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function Get0.get = Get0.get,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl1_IsValidKeyref_Interface as IsValidKeyref0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ToOwned0.to_owned = ToOwned0.to_owned,
    predicate IsValidKeyrefLg0.is_valid_keyref_lg = IsValidKeyrefLg0.is_valid_keyref_lg,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel3.deep_model,
    predicate LeLog0.le_log = LeLog0.le_log,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    function DeepModel2.deep_model = DeepModel4.deep_model,
    type DeepModelTy1.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    function DeepModel3.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Vecmap_Impl12_AsRef_Interface as AsRef0 with
    type k = k,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    type DeepModelTy2.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl6_Invariant as Invariant1 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl8_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    val Max0.mAX' = Max0.mAX',
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  let rec cfg entry_from_ref [@cfg:stackify] [#"../src/lib.rs" 111 4 111 80] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key_hint : Vecmap_KeyRef_Type.t_keyref k) (key : k) : Vecmap_Entry_Type.t_entry k v
    requires {[#"../src/lib.rs" 106 15 106 31] IsSorted0.is_sorted ( * self)}
    requires {[#"../src/lib.rs" 107 15 107 48] IsValidKeyrefLg0.is_valid_keyref_lg ( * self) key_hint}
    requires {[#"../src/lib.rs" 108 15 108 60] LeLog0.le_log (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key_hint)) (DeepModel0.deep_model key)}
    ensures { [#"../src/lib.rs" 109 4 109 75] forall e : Vecmap_OccupiedEntry_Type.t_occupiedentry k v . result = Vecmap_Entry_Type.C_Occupied e -> Invariant0.invariant' e }
    ensures { [#"../src/lib.rs" 110 4 110 73] forall e : Vecmap_VacantEntry_Type.t_vacantentry k v . result = Vecmap_Entry_Type.C_Vacant e -> Invariant1.invariant' e }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_Entry_Type.t_entry k v;
  var self_1 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var key_hint_2 : Vecmap_KeyRef_Type.t_keyref k;
  var key_3 : k;
  var _9 : ();
  var _10 : bool;
  var _11 : ();
  var _12 : bool;
  var _13 : bool;
  var _14 : Vecmap_VecMap_Type.t_vecmap k v;
  var _15 : Vecmap_KeyRef_Type.t_keyref k;
  var _16 : Vecmap_KeyRef_Type.t_keyref k;
  var _17 : Vecmap_KeyRef_Type.t_keyref k;
  var _18 : Vecmap_KeyRef_Type.t_keyref k;
  var _19 : ();
  var min_idx_20 : usize;
  var _21 : ();
  var iter_22 : Core_Ops_Range_Range_Type.t_range usize;
  var _23 : Core_Ops_Range_Range_Type.t_range usize;
  var _24 : usize;
  var _25 : usize;
  var _26 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var iter_old_27 : Ghost.ghost_ty (Core_Ops_Range_Range_Type.t_range usize);
  var _29 : ();
  var produced_30 : Ghost.ghost_ty (Seq.seq usize);
  var _33 : ();
  var _37 : ();
  var _38 : Core_Option_Option_Type.t_option usize;
  var _39 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _40 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _41 : isize;
  var i_42 : usize;
  var _43 : Ghost.ghost_ty (Seq.seq usize);
  var _45 : ();
  var i_46 : usize;
  var _47 : Core_Cmp_Ordering_Type.t_ordering;
  var _48 : k;
  var _49 : (k, v);
  var _50 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _51 : usize;
  var _52 : k;
  var _53 : k;
  var _54 : int8;
  var _55 : ();
  var _56 : Vecmap_OccupiedEntry_Type.t_occupiedentry k v;
  var _57 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var _58 : usize;
  var _59 : k;
  var _60 : ();
  var _61 : ();
  var _62 : bool;
  var _63 : bool;
  var _64 : usize;
  var _65 : ();
  var _66 : Vecmap_VacantEntry_Type.t_vacantentry k v;
  var _67 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var _68 : usize;
  var _69 : k;
  var _70 : ();
  var i_71 : usize;
  var _72 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _73 : Vecmap_VacantEntry_Type.t_vacantentry k v;
  var _74 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var _75 : usize;
  var _76 : k;
  {
    self_1 <- self;
    key_hint_2 <- key_hint;
    key_3 <- key;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    _10 <- true;
    switch (_10)
      | False -> goto BB8
      | True -> goto BB3
      end
  }
  BB3 {
    _14 <-  * self_1;
    _18 <- key_hint_2;
    _17 <- ([#"../src/lib.rs" 112 44 112 61] AsRef0.as_ref _18);
    goto BB4
  }
  BB4 {
    _16 <- _17;
    assume { Resolve0.resolve _17 };
    _15 <- _16;
    assume { Resolve1.resolve _16 };
    _13 <- ([#"../src/lib.rs" 112 22 112 62] IsValidKeyref0.is_valid_keyref _14 _15);
    goto BB5
  }
  BB5 {
    _12 <- not _13;
    switch (_12)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    assume { Resolve2.resolve self_1 };
    absurd
  }
  BB7 {
    _11 <- ();
    _9 <- ();
    goto BB9
  }
  BB8 {
    _9 <- ();
    goto BB9
  }
  BB9 {
    min_idx_20 <- Vecmap_KeyRef_Type.keyref_min_idx key_hint_2;
    _24 <- min_idx_20;
    _26 <- Vecmap_VecMap_Type.vecmap_v ( * self_1);
    _25 <- ([#"../src/lib.rs" 116 26 116 38] Len0.len _26);
    goto BB10
  }
  BB10 {
    _23 <- Core_Ops_Range_Range_Type.C_Range _24 _25;
    iter_22 <- ([#"../src/lib.rs" 115 8 115 29] IntoIter0.into_iter _23);
    goto BB11
  }
  BB11 {
    _29 <- ();
    iter_old_27 <- ([#"../src/lib.rs" 115 8 115 29] Ghost.new iter_22);
    goto BB12
  }
  BB12 {
    _33 <- ();
    produced_30 <- ([#"../src/lib.rs" 115 8 115 29] Ghost.new (Seq.empty ));
    goto BB13
  }
  BB13 {
    goto BB14
  }
  BB14 {
    invariant type_invariant { [#"../src/lib.rs" 115 8 115 29] Invariant2.invariant' iter_22 };
    invariant structural { [#"../src/lib.rs" 115 8 115 29] Produces0.produces (Ghost.inner iter_old_27) (Ghost.inner produced_30) iter_22 };
    invariant t { [#"../src/lib.rs" 115 23 115 27] true };
    _40 <- borrow_mut iter_22;
    iter_22 <-  ^ _40;
    _39 <- borrow_mut ( * _40);
    _40 <- { _40 with current = ( ^ _39) };
    _38 <- ([#"../src/lib.rs" 115 8 115 29] Next0.next _39);
    goto BB15
  }
  BB15 {
    assume { Resolve3.resolve _40 };
    switch (_38)
      | Core_Option_Option_Type.C_None -> goto BB16
      | Core_Option_Option_Type.C_Some _ -> goto BB18
      end
  }
  BB16 {
    _21 <- ();
    _72 <- Vecmap_VecMap_Type.vecmap_v ( * self_1);
    i_71 <- ([#"../src/lib.rs" 136 16 136 28] Len0.len _72);
    goto BB31
  }
  BB17 {
    assume { Resolve2.resolve self_1 };
    assume { Resolve4.resolve key_hint_2 };
    assume { Resolve5.resolve key_3 };
    absurd
  }
  BB18 {
    i_42 <- Core_Option_Option_Type.some_0 _38;
    _45 <- ();
    _43 <- ([#"../src/lib.rs" 115 8 115 29] Ghost.new (Seq.(++) (Ghost.inner produced_30) (Seq.singleton i_42)));
    goto BB19
  }
  BB19 {
    produced_30 <- _43;
    _43 <- any Ghost.ghost_ty (Seq.seq usize);
    i_46 <- i_42;
    _50 <- Vecmap_VecMap_Type.vecmap_v ( * self_1);
    _51 <- i_46;
    _49 <- ([#"../src/lib.rs" 117 18 117 27] Index0.index _50 _51);
    goto BB20
  }
  BB20 {
    _48 <- (let (a, _) = _49 in a);
    assume { Resolve6.resolve _49 };
    _53 <- key_3;
    _52 <- _53;
    assume { Resolve7.resolve _53 };
    _47 <- ([#"../src/lib.rs" 117 18 117 39] Cmp0.cmp _48 _52);
    goto BB21
  }
  BB21 {
    switch (_47)
      | Core_Cmp_Ordering_Type.C_Equal -> goto BB23
      | Core_Cmp_Ordering_Type.C_Greater -> goto BB26
      | _ -> goto BB22
      end
  }
  BB22 {
    _37 <- ();
    goto BB14
  }
  BB23 {
    _57 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _57) };
    assume { Resolve2.resolve self_1 };
    _58 <- i_46;
    assume { Resolve5.resolve _59 };
    _59 <- key_3;
    key_3 <- any k;
    _56 <- Vecmap_OccupiedEntry_Type.C_OccupiedEntry _57 _59 _58;
    goto BB24
  }
  BB24 {
    _0 <- Vecmap_Entry_Type.C_Occupied _56;
    goto BB25
  }
  BB25 {
    goto BB35
  }
  BB26 {
    _64 <- i_46;
    _63 <- ([#"../src/lib.rs" 126 28 126 34] _64 >= ([#"../src/lib.rs" 126 33 126 34] (1 : usize)));
    _62 <- not _63;
    switch (_62)
      | False -> goto BB28
      | True -> goto BB27
      end
  }
  BB27 {
    assume { Resolve2.resolve self_1 };
    absurd
  }
  BB28 {
    _61 <- ();
    _67 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _67) };
    assume { Resolve2.resolve self_1 };
    _68 <- i_46;
    assume { Resolve5.resolve _69 };
    _69 <- key_3;
    key_3 <- any k;
    _66 <- Vecmap_VacantEntry_Type.C_VacantEntry _67 _69 _68;
    goto BB29
  }
  BB29 {
    _0 <- Vecmap_Entry_Type.C_Vacant _66;
    goto BB30
  }
  BB30 {
    goto BB35
  }
  BB31 {
    _74 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _74) };
    assume { Resolve2.resolve self_1 };
    _75 <- i_71;
    assume { Resolve5.resolve _76 };
    _76 <- key_3;
    key_3 <- any k;
    _73 <- Vecmap_VacantEntry_Type.C_VacantEntry _74 _76 _75;
    goto BB32
  }
  BB32 {
    _0 <- Vecmap_Entry_Type.C_Vacant _73;
    goto BB33
  }
  BB33 {
    goto BB34
  }
  BB34 {
    goto BB37
  }
  BB35 {
    goto BB36
  }
  BB36 {
    goto BB37
  }
  BB37 {
    assume { Resolve4.resolve key_hint_2 };
    return _0
  }
  
end
module Core_Cmp_Impls_Impl10_Ge_Interface
  type a
  type b
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel1 with
    type t = b,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = a,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val ge [@cfg:stackify] (self : a) (other : b) : bool
    ensures { result = GeLog0.ge_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    
end
module Core_Cmp_Impls_Impl10_Ge
  type a
  type b
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = a
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Interface as DeepModel1 with
    type t = b,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Interface as DeepModel0 with
    type t = a,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val ge [@cfg:stackify] (self : a) (other : b) : bool
    ensures { result = GeLog0.ge_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    
end
module Vecmap_Impl1_FindRandomMappingAfter_Interface
  type k
  type v
  use mach.int.Int
  use seq.Seq
  use prelude.Borrow
  use mach.int.UInt64
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val find_random_mapping_after [@cfg:stackify] [#"../src/lib.rs" 156 4 156 93] (self : Vecmap_VecMap_Type.t_vecmap k v) (min_key_inclusive : k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"../src/lib.rs" 147 15 147 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 148 4 149 66] result = Core_Option_Option_Type.C_None -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive)) }
    ensures { [#"../src/lib.rs" 150 4 151 66] forall i : int . forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some mapping /\ i >= 0 /\ i < UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a)) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive) }
    ensures { [#"../src/lib.rs" 152 4 153 67] forall i : int . forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some mapping /\ i >= UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a)) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive) }
    ensures { [#"../src/lib.rs" 154 4 155 61] forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some mapping -> (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) (UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a))) in a) = (let (_, a) = mapping in a) }
    
end
module Vecmap_Impl1_FindRandomMappingAfter
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use prelude.IntSize
  use prelude.Slice
  use seq.Seq
  use mach.int.UInt64
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel3 with
    type t = (k, v),
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel2 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone Core_Slice_Index_Impl2_Output_Type as Output0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v)
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = seq (k, v),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = (k, v)
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = Output0.output
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = v
  clone Core_Cmp_Impls_Impl10_Ge_Interface as Ge0 with
    type a = k,
    type b = k,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_Get_Interface as Get0 with
    type t = (k, v),
    type i = usize,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    type Output0.output = Output0.output,
    predicate HasValue0.has_value = HasValue0.has_value
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = seq (k, v)
  clone Alloc_Vec_Impl10_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = k
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function DeepModel1.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  let rec cfg find_random_mapping_after [@cfg:stackify] [#"../src/lib.rs" 156 4 156 93] (self : Vecmap_VecMap_Type.t_vecmap k v) (min_key_inclusive : k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"../src/lib.rs" 147 15 147 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 148 4 149 66] result = Core_Option_Option_Type.C_None -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive)) }
    ensures { [#"../src/lib.rs" 150 4 151 66] forall i : int . forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some mapping /\ i >= 0 /\ i < UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a)) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive) }
    ensures { [#"../src/lib.rs" 152 4 153 67] forall i : int . forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some mapping /\ i >= UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a)) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model min_key_inclusive) }
    ensures { [#"../src/lib.rs" 154 4 155 61] forall mapping : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some mapping -> (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) (UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = mapping in a))) in a) = (let (_, a) = mapping in a) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v);
  var self_1 : Vecmap_VecMap_Type.t_vecmap k v;
  var min_key_inclusive_2 : k;
  var _8 : Core_Result_Result_Type.t_result usize usize;
  var _9 : Vecmap_VecMap_Type.t_vecmap k v;
  var _10 : k;
  var _11 : k;
  var _12 : isize;
  var index_13 : usize;
  var key_14 : k;
  var value_15 : v;
  var _16 : (k, v);
  var _17 : (k, v);
  var _18 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _19 : usize;
  var _20 : (Vecmap_KeyRef_Type.t_keyref k, v);
  var _21 : Vecmap_KeyRef_Type.t_keyref k;
  var _22 : k;
  var _23 : usize;
  var _24 : v;
  var index_25 : usize;
  var _26 : Core_Option_Option_Type.t_option (k, v);
  var _27 : seq (k, v);
  var _28 : seq (k, v);
  var _29 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _30 : usize;
  var _31 : isize;
  var key_32 : k;
  var value_33 : v;
  var _34 : ();
  var _35 : bool;
  var _36 : bool;
  var _37 : k;
  var _38 : k;
  var _39 : k;
  var _40 : k;
  var _41 : ();
  var _42 : (Vecmap_KeyRef_Type.t_keyref k, v);
  var _43 : Vecmap_KeyRef_Type.t_keyref k;
  var _44 : k;
  var _45 : usize;
  var _46 : v;
  {
    self_1 <- self;
    min_key_inclusive_2 <- min_key_inclusive;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _9 <- self_1;
    _11 <- min_key_inclusive_2;
    _10 <- _11;
    assume { Resolve0.resolve _11 };
    _8 <- ([#"../src/lib.rs" 157 14 157 45] FindK0.find_k _9 _10);
    goto BB4
  }
  BB4 {
    switch (_8)
      | Core_Result_Result_Type.C_Ok _ -> goto BB7
      | Core_Result_Result_Type.C_Err _ -> goto BB5
      end
  }
  BB5 {
    index_25 <- Core_Result_Result_Type.err_0 _8;
    _29 <- Vecmap_VecMap_Type.vecmap_v self_1;
    assume { Resolve1.resolve self_1 };
    _28 <- ([#"../src/lib.rs" 168 32 168 49] Deref0.deref _29);
    goto BB9
  }
  BB6 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve min_key_inclusive_2 };
    absurd
  }
  BB7 {
    index_13 <- Core_Result_Result_Type.ok_0 _8;
    _18 <- Vecmap_VecMap_Type.vecmap_v self_1;
    assume { Resolve1.resolve self_1 };
    _19 <- index_13;
    _17 <- ([#"../src/lib.rs" 159 36 159 49] Index0.index _18 _19);
    goto BB8
  }
  BB8 {
    _16 <- _17;
    assume { Resolve6.resolve _17 };
    key_14 <- (let (a, _) = _16 in a);
    value_15 <- (let (_, a) = _16 in a);
    assume { Resolve6.resolve _16 };
    _22 <- key_14;
    assume { Resolve0.resolve key_14 };
    _23 <- index_13;
    _21 <- Vecmap_KeyRef_Type.C_KeyRef _22 _23;
    _24 <- value_15;
    assume { Resolve5.resolve value_15 };
    _20 <- (_21, _24);
    _0 <- Core_Option_Option_Type.C_Some _20;
    goto BB18
  }
  BB9 {
    _27 <- _28;
    assume { Resolve3.resolve _28 };
    _30 <- index_25;
    _26 <- ([#"../src/lib.rs" 168 32 168 49] Get0.get _27 _30);
    goto BB10
  }
  BB10 {
    switch (_26)
      | Core_Option_Option_Type.C_None -> goto BB11
      | Core_Option_Option_Type.C_Some _ -> goto BB13
      end
  }
  BB11 {
    assume { Resolve4.resolve _26 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB17
  }
  BB12 {
    assume { Resolve2.resolve min_key_inclusive_2 };
    assume { Resolve4.resolve _26 };
    absurd
  }
  BB13 {
    key_32 <- (let (a, _) = Core_Option_Option_Type.some_0 _26 in a);
    value_33 <- (let (_, a) = Core_Option_Option_Type.some_0 _26 in a);
    assume { Resolve4.resolve _26 };
    _37 <- key_32;
    _40 <- min_key_inclusive_2;
    _39 <- _40;
    assume { Resolve0.resolve _40 };
    _38 <- _39;
    assume { Resolve0.resolve _39 };
    _36 <- ([#"../src/lib.rs" 170 28 170 53] Ge0.ge _37 _38);
    goto BB14
  }
  BB14 {
    _35 <- not _36;
    switch (_35)
      | False -> goto BB16
      | True -> goto BB15
      end
  }
  BB15 {
    assume { Resolve0.resolve key_32 };
    assume { Resolve5.resolve value_33 };
    absurd
  }
  BB16 {
    _34 <- ();
    _44 <- key_32;
    assume { Resolve0.resolve key_32 };
    _45 <- index_25;
    _43 <- Vecmap_KeyRef_Type.C_KeyRef _44 _45;
    _46 <- value_33;
    assume { Resolve5.resolve value_33 };
    _42 <- (_43, _46);
    _0 <- Core_Option_Option_Type.C_Some _42;
    goto BB17
  }
  BB17 {
    goto BB18
  }
  BB18 {
    goto BB19
  }
  BB19 {
    assume { Resolve2.resolve min_key_inclusive_2 };
    return _0
  }
  
end
module CreusotContracts_Model_Impl3_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module Alloc_Vec_Impl1_Insert_Interface
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  use prelude.UIntSize
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  clone Core_Num_Impl12_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val insert [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : usize) (element : t) : ()
    ensures { Seq.length (ShallowModel0.shallow_model ( ^ self)) = Seq.length (ShallowModel1.shallow_model self) + 1 }
    ensures { forall i : int . 0 <= i /\ i < UInt64.to_int index -> Seq.get (ShallowModel0.shallow_model ( ^ self)) i = Seq.get (ShallowModel1.shallow_model self) i }
    ensures { Seq.get (ShallowModel0.shallow_model ( ^ self)) (UInt64.to_int index) = element }
    ensures { forall i : int . UInt64.to_int index < i /\ i < Seq.length (ShallowModel0.shallow_model ( ^ self)) -> Seq.get (ShallowModel0.shallow_model ( ^ self)) i = Seq.get (ShallowModel1.shallow_model self) (i - 1) }
    
end
module Alloc_Vec_Impl1_Insert
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  use prelude.UIntSize
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  clone Core_Num_Impl12_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl3_ShallowModel_Interface as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel0 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val insert [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : usize) (element : t) : ()
    ensures { Seq.length (ShallowModel0.shallow_model ( ^ self)) = Seq.length (ShallowModel1.shallow_model self) + 1 }
    ensures { forall i : int . 0 <= i /\ i < UInt64.to_int index -> Seq.get (ShallowModel0.shallow_model ( ^ self)) i = Seq.get (ShallowModel1.shallow_model self) i }
    ensures { Seq.get (ShallowModel0.shallow_model ( ^ self)) (UInt64.to_int index) = element }
    ensures { forall i : int . UInt64.to_int index < i /\ i < Seq.length (ShallowModel0.shallow_model ( ^ self)) -> Seq.get (ShallowModel0.shallow_model ( ^ self)) i = Seq.get (ShallowModel1.shallow_model self) (i - 1) }
    
end
module Vecmap_Impl1_InsertInternal_Interface
  type k
  type v
  use mach.int.UInt64
  use prelude.Borrow
  use seq.Seq
  use mach.int.Int
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val insert_internal [@cfg:stackify] [#"../src/lib.rs" 399 4 399 63] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (idx : usize) (key : k) (value : v) : ()
    requires {[#"../src/lib.rs" 380 15 380 38] UInt64.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))}
    ensures { [#"../src/lib.rs" 381 14 381 55] Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) + 1 }
    ensures { [#"../src/lib.rs" 382 4 382 85] forall i : int . 0 <= i /\ i < UInt64.to_int idx -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i }
    ensures { [#"../src/lib.rs" 383 14 383 48] Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) (UInt64.to_int idx) = (key, value) }
    ensures { [#"../src/lib.rs" 384 4 384 105] forall i : int . UInt64.to_int idx < i /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i - 1) }
    ensures { [#"../src/lib.rs" 385 4 385 80] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) = 0 -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 386 4 390 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UInt64.to_int idx > 0 /\ UInt64.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UInt64.to_int idx) in a)) (DeepModel0.deep_model key) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UInt64.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 391 4 394 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UInt64.to_int idx = 0 /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UInt64.to_int idx) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 395 4 398 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UInt64.to_int idx = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UInt64.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    
end
module Vecmap_Impl1_InsertInternal
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.UInt64
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone Alloc_Vec_Impl1_Insert_Interface as Insert0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec cfg insert_internal [@cfg:stackify] [#"../src/lib.rs" 399 4 399 63] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (idx : usize) (key : k) (value : v) : ()
    requires {[#"../src/lib.rs" 380 15 380 38] UInt64.to_int idx <= Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))}
    ensures { [#"../src/lib.rs" 381 14 381 55] Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) + 1 }
    ensures { [#"../src/lib.rs" 382 4 382 85] forall i : int . 0 <= i /\ i < UInt64.to_int idx -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i }
    ensures { [#"../src/lib.rs" 383 14 383 48] Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) (UInt64.to_int idx) = (key, value) }
    ensures { [#"../src/lib.rs" 384 4 384 105] forall i : int . UInt64.to_int idx < i /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i - 1) }
    ensures { [#"../src/lib.rs" 385 4 385 80] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) = 0 -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 386 4 390 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UInt64.to_int idx > 0 /\ UInt64.to_int idx < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UInt64.to_int idx) in a)) (DeepModel0.deep_model key) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UInt64.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 391 4 394 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UInt64.to_int idx = 0 /\ GtLog0.gt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UInt64.to_int idx) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 395 4 398 6] IsSorted0.is_sorted ( * self) /\ Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) > 0 /\ UInt64.to_int idx = Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) /\ LtLog0.lt_log (DeepModel0.deep_model (let (a, _) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (UInt64.to_int idx - 1) in a)) (DeepModel0.deep_model key) -> IsSorted0.is_sorted ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var idx_2 : usize;
  var key_3 : k;
  var value_4 : v;
  var _14 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  var _15 : usize;
  var _16 : (k, v);
  var _17 : k;
  var _18 : v;
  {
    self_1 <- self;
    idx_2 <- idx;
    key_3 <- key;
    value_4 <- value;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    _14 <- borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * self_1));
    self_1 <- { self_1 with current = (let Vecmap_VecMap_Type.C_VecMap a =  * self_1 in Vecmap_VecMap_Type.C_VecMap ( ^ _14)) };
    _15 <- idx_2;
    assume { Resolve0.resolve _17 };
    _17 <- key_3;
    key_3 <- any k;
    assume { Resolve1.resolve _18 };
    _18 <- value_4;
    value_4 <- any v;
    _16 <- (_17, _18);
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    _0 <- ([#"../src/lib.rs" 400 8 400 40] Insert0.insert _14 _15 _16);
    goto BB7
  }
  BB7 {
    assume { Resolve2.resolve self_1 };
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl17_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = seq t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val index_mut [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    
end
module Alloc_Vec_Impl17_IndexMut
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = seq t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface as ResolveElswhere0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel1 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface as HasValue0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface as InBounds0 with
    type self = i,
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy
  clone CreusotContracts_Model_Impl3_ShallowModel_Interface as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val index_mut [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    
end
module Core_Mem_Replace_Interface
  type t
  use prelude.Borrow
  val replace [@cfg:stackify] (dest : borrowed t) (src : t) : t
    ensures {  ^ dest = src }
    ensures { result =  * dest }
    
end
module Core_Mem_Replace
  type t
  use prelude.Borrow
  val replace [@cfg:stackify] (dest : borrowed t) (src : t) : t
    ensures {  ^ dest = src }
    ensures { result =  * dest }
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Stub
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Interface
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere
  type t
  use mach.int.Int
  use prelude.UIntSize
  use seq.Seq
  use mach.int.UInt64
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    forall i : int . 0 <= i /\ i <> UInt64.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Vecmap_Impl1_Insert_Interface
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val insert [@cfg:stackify] [#"../src/lib.rs" 189 4 189 59] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) (value : v) : Core_Option_Option_Type.t_option v
    requires {[#"../src/lib.rs" 186 4 186 40] IsSorted0.is_sorted ( * self)}
    ensures { [#"../src/lib.rs" 186 4 186 40] IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 187 4 188 86] exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) -> Seq.get (KeySeq0.key_seq ( ^ self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i in a) = value }
    
end
module Vecmap_Impl1_Insert
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use prelude.IntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v)
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  clone Core_Slice_Index_Impl2_Output_Type as Output0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve5 with
    type t = v
  clone Core_Mem_Replace_Interface as Replace0 with
    type t = v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve4 with
    type t = (k, v)
  clone Alloc_Vec_Impl17_IndexMut_Interface as IndexMut0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = Output0.output,
    val Max0.mAX' = Max0.mAX'
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_InsertInternal_Interface as InsertInternal0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = k
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function DeepModel1.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  let rec cfg insert [@cfg:stackify] [#"../src/lib.rs" 189 4 189 59] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) (value : v) : Core_Option_Option_Type.t_option v
    requires {[#"../src/lib.rs" 186 4 186 40] IsSorted0.is_sorted ( * self)}
    ensures { [#"../src/lib.rs" 186 4 186 40] IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 187 4 188 86] exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) -> Seq.get (KeySeq0.key_seq ( ^ self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self))) i in a) = value }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option v;
  var self_1 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var key_2 : k;
  var value_3 : v;
  var _7 : Core_Result_Result_Type.t_result usize usize;
  var _8 : Vecmap_VecMap_Type.t_vecmap k v;
  var _9 : k;
  var _10 : k;
  var _11 : isize;
  var index_12 : usize;
  var _13 : v;
  var _14 : borrowed v;
  var _15 : borrowed v;
  var _16 : borrowed (k, v);
  var _17 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  var _18 : usize;
  var _19 : v;
  var index_20 : usize;
  var _21 : ();
  var _22 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var _23 : usize;
  var _24 : k;
  var _25 : v;
  {
    self_1 <- self;
    key_2 <- key;
    value_3 <- value;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _8 <-  * self_1;
    _10 <- key_2;
    _9 <- _10;
    assume { Resolve0.resolve _10 };
    _7 <- ([#"../src/lib.rs" 190 14 190 31] FindK0.find_k _8 _9);
    goto BB2
  }
  BB2 {
    switch (_7)
      | Core_Result_Result_Type.C_Ok _ -> goto BB5
      | Core_Result_Result_Type.C_Err _ -> goto BB3
      end
  }
  BB3 {
    index_20 <- Core_Result_Result_Type.err_0 _7;
    _22 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _22) };
    _23 <- index_20;
    assume { Resolve2.resolve _24 };
    _24 <- key_2;
    key_2 <- any k;
    assume { Resolve3.resolve _25 };
    _25 <- value_3;
    value_3 <- any v;
    _21 <- ([#"../src/lib.rs" 193 16 193 55] InsertInternal0.insert_internal _22 _23 _24 _25);
    goto BB9
  }
  BB4 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve key_2 };
    assume { Resolve3.resolve value_3 };
    absurd
  }
  BB5 {
    index_12 <- Core_Result_Result_Type.ok_0 _7;
    _17 <- borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * self_1));
    self_1 <- { self_1 with current = (let Vecmap_VecMap_Type.C_VecMap a =  * self_1 in Vecmap_VecMap_Type.C_VecMap ( ^ _17)) };
    assume { Resolve1.resolve self_1 };
    _18 <- index_12;
    _16 <- ([#"../src/lib.rs" 191 53 191 66] IndexMut0.index_mut _17 _18);
    goto BB6
  }
  BB6 {
    _15 <- borrow_mut (let (_, a) =  * _16 in a);
    _16 <- { _16 with current = (let (a, b) =  * _16 in (a,  ^ _15)) };
    assume { Resolve4.resolve _16 };
    _14 <- borrow_mut ( * _15);
    _15 <- { _15 with current = ( ^ _14) };
    assume { Resolve3.resolve _19 };
    _19 <- value_3;
    value_3 <- any v;
    _13 <- ([#"../src/lib.rs" 191 30 191 76] Replace0.replace _14 _19);
    goto BB7
  }
  BB7 {
    assume { Resolve5.resolve _15 };
    _0 <- Core_Option_Option_Type.C_Some _13;
    goto BB8
  }
  BB8 {
    goto BB10
  }
  BB9 {
    assume { Resolve1.resolve self_1 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    return _0
  }
  
end
module Alloc_Vec_Impl1_Remove_Interface
  type t
  type a
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Borrow
  use seq_ext.SeqExt
  use prelude.UIntSize
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val remove [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : usize) : t
    requires {UInt64.to_int index < Seq.length (ShallowModel0.shallow_model self)}
    ensures { result = Seq.get (ShallowModel0.shallow_model self) (UInt64.to_int index) }
    ensures { ShallowModel1.shallow_model ( ^ self) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model self) 0 (UInt64.to_int index)) (SeqExt.subsequence (ShallowModel0.shallow_model self) (UInt64.to_int index + 1) (Seq.length (ShallowModel0.shallow_model self))) }
    ensures { Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) - 1 }
    
end
module Alloc_Vec_Impl1_Remove
  type t
  type a
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Borrow
  use seq_ext.SeqExt
  use prelude.UIntSize
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t,
    type a = a
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface as ShallowModel1 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel_Interface as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  val remove [@cfg:stackify] (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : usize) : t
    requires {UInt64.to_int index < Seq.length (ShallowModel0.shallow_model self)}
    ensures { result = Seq.get (ShallowModel0.shallow_model self) (UInt64.to_int index) }
    ensures { ShallowModel1.shallow_model ( ^ self) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model self) 0 (UInt64.to_int index)) (SeqExt.subsequence (ShallowModel0.shallow_model self) (UInt64.to_int index + 1) (Seq.length (ShallowModel0.shallow_model self))) }
    ensures { Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) - 1 }
    
end
module CreusotContracts_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = t2
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t1
  predicate resolve (self : (t1, t2)) =
    Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module Vecmap_Impl1_Remove_Interface
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use seq.Seq
  use seq_ext.SeqExt
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val remove [@cfg:stackify] [#"../src/lib.rs" 211 4 211 50] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"../src/lib.rs" 201 4 201 40] IsSorted0.is_sorted ( * self)}
    ensures { [#"../src/lib.rs" 201 4 201 40] IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 202 4 204 30] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq ( * self)) (DeepModel0.deep_model key) /\  * self =  ^ self }
    ensures { [#"../src/lib.rs" 205 4 210 17] forall v : v . result = Core_Option_Option_Type.C_Some v -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) -> Seq.get (KeySeq0.key_seq ( * self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i in a) = v /\ ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self)) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) 0 i) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i + 1) (Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))))) }
    
end
module Vecmap_Impl1_Remove
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use prelude.IntSize
  use seq.Seq
  use seq_ext.SeqExt
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = k
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = v
  clone CreusotContracts_Resolve_Impl0_Resolve as Resolve3 with
    type t1 = k,
    type t2 = v,
    predicate Resolve0.resolve = Resolve4.resolve,
    predicate Resolve1.resolve = Resolve2.resolve
  clone Alloc_Vec_Impl1_Remove_Interface as Remove0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  let rec cfg remove [@cfg:stackify] [#"../src/lib.rs" 211 4 211 50] (self : borrowed (Vecmap_VecMap_Type.t_vecmap k v)) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"../src/lib.rs" 201 4 201 40] IsSorted0.is_sorted ( * self)}
    ensures { [#"../src/lib.rs" 201 4 201 40] IsSorted0.is_sorted ( ^ self) }
    ensures { [#"../src/lib.rs" 202 4 204 30] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq ( * self)) (DeepModel0.deep_model key) /\  * self =  ^ self }
    ensures { [#"../src/lib.rs" 205 4 210 17] forall v : v . result = Core_Option_Option_Type.C_Some v -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) -> Seq.get (KeySeq0.key_seq ( * self)) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) i in a) = v /\ ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( ^ self)) = Seq.(++) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) 0 i) (SeqExt.subsequence (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self))) (i + 1) (Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * self)))))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option v;
  var self_1 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var key_2 : k;
  var _7 : Core_Result_Result_Type.t_result usize usize;
  var _8 : Vecmap_VecMap_Type.t_vecmap k v;
  var _9 : k;
  var _10 : isize;
  var index_11 : usize;
  var _12 : v;
  var _13 : (k, v);
  var _14 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  var _15 : usize;
  {
    self_1 <- self;
    key_2 <- key;
    goto BB0
  }
  BB0 {
    _8 <-  * self_1;
    _9 <- key_2;
    assume { Resolve0.resolve key_2 };
    _7 <- ([#"../src/lib.rs" 212 14 212 30] FindK0.find_k _8 _9);
    goto BB1
  }
  BB1 {
    switch (_7)
      | Core_Result_Result_Type.C_Ok _ -> goto BB4
      | Core_Result_Result_Type.C_Err _ -> goto BB2
      end
  }
  BB2 {
    assume { Resolve1.resolve self_1 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB8
  }
  BB3 {
    assume { Resolve1.resolve self_1 };
    absurd
  }
  BB4 {
    index_11 <- Core_Result_Result_Type.ok_0 _7;
    _14 <- borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * self_1));
    self_1 <- { self_1 with current = (let Vecmap_VecMap_Type.C_VecMap a =  * self_1 in Vecmap_VecMap_Type.C_VecMap ( ^ _14)) };
    _15 <- index_11;
    _13 <- ([#"../src/lib.rs" 213 30 213 50] Remove0.remove _14 _15);
    goto BB5
  }
  BB5 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve _12 };
    _12 <- (let (_, a) = _13 in a);
    _13 <- (let (a, b) = _13 in (a, any v));
    _0 <- Core_Option_Option_Type.C_Some _12;
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    assume { Resolve3.resolve _13 };
    goto BB8
  }
  BB8 {
    return _0
  }
  
end
module Vecmap_Impl1_Get_Interface
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val get [@cfg:stackify] [#"../src/lib.rs" 224 4 224 44] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"../src/lib.rs" 219 15 219 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 220 4 220 77] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    ensures { [#"../src/lib.rs" 221 4 223 77] forall v : v . result = Core_Option_Option_Type.C_Some v -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = v) }
    
end
module Vecmap_Impl1_Get
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use prelude.IntSize
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v)
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  clone Core_Slice_Index_Impl2_Output_Type as Output0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = (k, v)
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = Output0.output
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  let rec cfg get [@cfg:stackify] [#"../src/lib.rs" 224 4 224 44] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : Core_Option_Option_Type.t_option v
    requires {[#"../src/lib.rs" 219 15 219 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 220 4 220 77] result = Core_Option_Option_Type.C_None -> not Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    ensures { [#"../src/lib.rs" 221 4 223 77] forall v : v . result = Core_Option_Option_Type.C_Some v -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model key /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = v) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option v;
  var self_1 : Vecmap_VecMap_Type.t_vecmap k v;
  var key_2 : k;
  var _6 : Core_Result_Result_Type.t_result usize usize;
  var _7 : Vecmap_VecMap_Type.t_vecmap k v;
  var _8 : k;
  var _9 : isize;
  var index_10 : usize;
  var _11 : v;
  var _12 : v;
  var _13 : (k, v);
  var _14 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _15 : usize;
  {
    self_1 <- self;
    key_2 <- key;
    goto BB0
  }
  BB0 {
    _7 <- self_1;
    _8 <- key_2;
    assume { Resolve0.resolve key_2 };
    _6 <- ([#"../src/lib.rs" 225 14 225 30] FindK0.find_k _7 _8);
    goto BB1
  }
  BB1 {
    switch (_6)
      | Core_Result_Result_Type.C_Ok _ -> goto BB4
      | Core_Result_Result_Type.C_Err _ -> goto BB2
      end
  }
  BB2 {
    assume { Resolve1.resolve self_1 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB6
  }
  BB3 {
    assume { Resolve1.resolve self_1 };
    absurd
  }
  BB4 {
    index_10 <- Core_Result_Result_Type.ok_0 _6;
    _14 <- Vecmap_VecMap_Type.vecmap_v self_1;
    assume { Resolve1.resolve self_1 };
    _15 <- index_10;
    _13 <- ([#"../src/lib.rs" 226 31 226 44] Index0.index _14 _15);
    goto BB5
  }
  BB5 {
    _12 <- (let (_, a) = _13 in a);
    assume { Resolve2.resolve _13 };
    _11 <- _12;
    assume { Resolve3.resolve _12 };
    _0 <- Core_Option_Option_Type.C_Some _11;
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Core_Result_Impl0_IsOk_Interface
  type t
  type e
  use prelude.Borrow
  use Core_Result_Result_Type as Core_Result_Result_Type
  val is_ok [@cfg:stackify] (self : Core_Result_Result_Type.t_result t e) : bool
    ensures { result = (exists t : t . self = Core_Result_Result_Type.C_Ok t) }
    
end
module Core_Result_Impl0_IsOk
  type t
  type e
  use prelude.Borrow
  use Core_Result_Result_Type as Core_Result_Result_Type
  val is_ok [@cfg:stackify] (self : Core_Result_Result_Type.t_result t e) : bool
    ensures { result = (exists t : t . self = Core_Result_Result_Type.C_Ok t) }
    
end
module Vecmap_Impl1_ContainsKey_Interface
  type k
  type v
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Logic_Seq_Impl0_Contains_Stub as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val contains_key [@cfg:stackify] [#"../src/lib.rs" 234 4 234 47] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : bool
    requires {[#"../src/lib.rs" 232 15 232 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 233 14 233 65] result = Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    
end
module Vecmap_Impl1_ContainsKey
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Result_Result_Type as Core_Result_Result_Type
  clone Core_Result_Impl0_IsOk_Interface as IsOk0 with
    type t = usize,
    type e = usize
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Logic_Seq_Impl0_Contains as Contains0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_FindK_Interface as FindK0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate Contains0.contains = Contains0.contains,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function DeepModel1.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg contains_key [@cfg:stackify] [#"../src/lib.rs" 234 4 234 47] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : k) : bool
    requires {[#"../src/lib.rs" 232 15 232 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 233 14 233 65] result = Contains0.contains (KeySeq0.key_seq self) (DeepModel0.deep_model key) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : Vecmap_VecMap_Type.t_vecmap k v;
  var key_2 : k;
  var _5 : Core_Result_Result_Type.t_result usize usize;
  var _6 : Core_Result_Result_Type.t_result usize usize;
  var _7 : Vecmap_VecMap_Type.t_vecmap k v;
  var _8 : k;
  {
    self_1 <- self;
    key_2 <- key;
    goto BB0
  }
  BB0 {
    _7 <- self_1;
    assume { Resolve0.resolve self_1 };
    _8 <- key_2;
    assume { Resolve1.resolve key_2 };
    _6 <- ([#"../src/lib.rs" 235 8 235 24] FindK0.find_k _7 _8);
    goto BB1
  }
  BB1 {
    _5 <- _6;
    _0 <- ([#"../src/lib.rs" 235 8 235 32] IsOk0.is_ok _5);
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Core_Cmp_PartialOrd_Gt_Interface
  type self
  type rhs
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel1 with
    type t = rhs,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val gt [@cfg:stackify] (self : self) (other : rhs) : bool
    ensures { result = GtLog0.gt_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    
end
module Core_Cmp_PartialOrd_Gt
  type self
  type rhs
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Interface as DeepModel1 with
    type t = rhs,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Interface as DeepModel0 with
    type t = self,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  val gt [@cfg:stackify] (self : self) (other : rhs) : bool
    ensures { result = GtLog0.gt_log (DeepModel0.deep_model self) (DeepModel1.deep_model other) }
    
end
module Vecmap_Impl1_NextMapping_Interface
  type k
  type v
  use mach.int.Int
  use seq.Seq
  use prelude.Borrow
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val next_mapping [@cfg:stackify] [#"../src/lib.rs" 252 4 252 75] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"../src/lib.rs" 240 15 240 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 241 4 243 57] result = Core_Option_Option_Type.C_None -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    ensures { [#"../src/lib.rs" 244 4 251 57] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some entry -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)) /\ GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)) /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = (let (_, a) = entry in a) /\ (forall j : int . j >= 0 /\ j < i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a))) /\ LeLog0.le_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)))) }
    
end
module Vecmap_Impl1_NextMapping
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.IntSize
  use mach.int.UInt64
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Logic_Seq_Impl0_Get as Get0 with
    type t = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v)
  clone Core_Slice_Index_Impl2_Output_Type as Output0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  clone CreusotContracts_Logic_Int_Impl18_DeepModel as DeepModel4
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve1.resolve,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone Core_Iter_Range_Impl3_Item_Type as Item0 with
    type a = usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel4.deep_model
  clone CreusotContracts_Std1_Ops_Impl3_Invariant as Invariant0 with
    type idx = usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans as ProducesTrans0 with
    type idx = usize,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl as ProducesRefl0 with
    type idx = usize,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Type as IntoIter1 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant0.invariant'
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl0_DeepModelTy_Type as DeepModelTy1 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl10_DeepModel as DeepModel3 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl10_DeepModel as DeepModel2 with
    type k = k,
    type DeepModelTy0.deepModelTy = DeepModelTy1.deepModelTy,
    function DeepModel0.deep_model = DeepModel0.deep_model
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_IsValidKeyrefLg as IsValidKeyrefLg0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    predicate LeLog0.le_log = LeLog0.le_log,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function Get0.get = Get0.get,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl13_ToOwned as ToOwned0 with
    type k = k,
    function DeepModel0.deep_model = DeepModel2.deep_model,
    function DeepModel1.deep_model = DeepModel3.deep_model,
    type DeepModelTy1.deepModelTy = DeepModelTy0.deepModelTy,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve6 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve5 with
    type self = k
  clone Core_Cmp_PartialOrd_Gt_Interface as Gt0 with
    type self = k,
    type rhs = k,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    function DeepModel1.deep_model = DeepModel0.deep_model,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = (k, v)
  clone Alloc_Vec_Impl16_Index_Interface as Index0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = Output0.output
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    predicate Invariant0.invariant' = Invariant0.invariant',
    type Item0.item = Item0.item,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post,
    predicate Invariant0.invariant' = Invariant0.invariant'
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Vecmap_Impl1_IsValidKeyref_Interface as IsValidKeyref0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ToOwned0.to_owned = ToOwned0.to_owned,
    predicate IsValidKeyrefLg0.is_valid_keyref_lg = IsValidKeyrefLg0.is_valid_keyref_lg,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate LeLog0.le_log = LeLog0.le_log,
    function DeepModel1.deep_model = DeepModel2.deep_model,
    function DeepModel2.deep_model = DeepModel3.deep_model,
    type DeepModelTy1.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    function DeepModel3.deep_model = DeepModel1.deep_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  let rec cfg next_mapping [@cfg:stackify] [#"../src/lib.rs" 252 4 252 75] (self : Vecmap_VecMap_Type.t_vecmap k v) (key : Vecmap_KeyRef_Type.t_keyref k) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"../src/lib.rs" 240 15 240 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 241 4 243 57] result = Core_Option_Option_Type.C_None -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key))) }
    ensures { [#"../src/lib.rs" 244 4 251 57] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some entry -> (exists i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> Seq.get (KeySeq0.key_seq self) i = DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)) /\ GtLog0.gt_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)) /\ (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) i in a) = (let (_, a) = entry in a) /\ (forall j : int . j >= 0 /\ j < i -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a))) /\ LeLog0.le_log (Seq.get (KeySeq0.key_seq self) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key)))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v);
  var self_1 : Vecmap_VecMap_Type.t_vecmap k v;
  var key_2 : Vecmap_KeyRef_Type.t_keyref k;
  var from_6 : usize;
  var _7 : bool;
  var _8 : Vecmap_VecMap_Type.t_vecmap k v;
  var _9 : Vecmap_KeyRef_Type.t_keyref k;
  var _10 : Vecmap_KeyRef_Type.t_keyref k;
  var _11 : ();
  var iter_12 : Core_Ops_Range_Range_Type.t_range usize;
  var _13 : Core_Ops_Range_Range_Type.t_range usize;
  var _14 : usize;
  var _15 : usize;
  var _16 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var iter_old_17 : Ghost.ghost_ty (Core_Ops_Range_Range_Type.t_range usize);
  var _19 : ();
  var produced_20 : Ghost.ghost_ty (Seq.seq usize);
  var _23 : ();
  var _27 : ();
  var _28 : Core_Option_Option_Type.t_option usize;
  var _29 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _30 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _31 : isize;
  var i_32 : usize;
  var _33 : Ghost.ghost_ty (Seq.seq usize);
  var _35 : ();
  var idx_36 : usize;
  var _37 : bool;
  var _38 : k;
  var _39 : (k, v);
  var _40 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _41 : usize;
  var _42 : k;
  var _43 : ();
  var key_44 : k;
  var value_45 : v;
  var _46 : (k, v);
  var _47 : (k, v);
  var _48 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _49 : usize;
  var _50 : (Vecmap_KeyRef_Type.t_keyref k, v);
  var _51 : Vecmap_KeyRef_Type.t_keyref k;
  var _52 : usize;
  var _53 : k;
  var _54 : v;
  var _55 : ();
  {
    self_1 <- self;
    key_2 <- key;
    goto BB0
  }
  BB0 {
    _8 <- self_1;
    _10 <- key_2;
    _9 <- _10;
    assume { Resolve0.resolve _10 };
    _7 <- ([#"../src/lib.rs" 253 22 253 48] IsValidKeyref0.is_valid_keyref _8 _9);
    goto BB1
  }
  BB1 {
    switch (_7)
      | False -> goto BB3
      | True -> goto BB2
      end
  }
  BB2 {
    from_6 <- Vecmap_KeyRef_Type.keyref_min_idx key_2;
    goto BB4
  }
  BB3 {
    from_6 <- ([#"../src/lib.rs" 256 12 256 13] (0 : usize));
    goto BB4
  }
  BB4 {
    _14 <- from_6;
    _16 <- Vecmap_VecMap_Type.vecmap_v self_1;
    _15 <- ([#"../src/lib.rs" 261 25 261 37] Len0.len _16);
    goto BB5
  }
  BB5 {
    _13 <- Core_Ops_Range_Range_Type.C_Range _14 _15;
    iter_12 <- ([#"../src/lib.rs" 259 8 260 63] IntoIter0.into_iter _13);
    goto BB6
  }
  BB6 {
    _19 <- ();
    iter_old_17 <- ([#"../src/lib.rs" 259 8 260 63] Ghost.new iter_12);
    goto BB7
  }
  BB7 {
    _23 <- ();
    produced_20 <- ([#"../src/lib.rs" 259 8 260 63] Ghost.new (Seq.empty ));
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    invariant type_invariant { [#"../src/lib.rs" 259 8 260 63] Invariant0.invariant' iter_12 };
    invariant structural { [#"../src/lib.rs" 259 8 260 63] Produces0.produces (Ghost.inner iter_old_17) (Ghost.inner produced_20) iter_12 };
    invariant prev_leq { [#"../src/lib.rs" 259 8 260 63] forall j : int . j >= 0 /\ j < Seq.length (Ghost.inner produced_20) + UInt64.to_int from_6 -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self_1) j) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key key_2)) };
    _30 <- borrow_mut iter_12;
    iter_12 <-  ^ _30;
    _29 <- borrow_mut ( * _30);
    _30 <- { _30 with current = ( ^ _29) };
    _28 <- ([#"../src/lib.rs" 259 8 260 63] Next0.next _29);
    goto BB10
  }
  BB10 {
    assume { Resolve1.resolve _30 };
    switch (_28)
      | Core_Option_Option_Type.C_None -> goto BB11
      | Core_Option_Option_Type.C_Some _ -> goto BB13
      end
  }
  BB11 {
    assume { Resolve2.resolve self_1 };
    assume { Resolve3.resolve key_2 };
    _11 <- ();
    _0 <- Core_Option_Option_Type.C_None;
    goto BB20
  }
  BB12 {
    assume { Resolve2.resolve self_1 };
    assume { Resolve3.resolve key_2 };
    absurd
  }
  BB13 {
    i_32 <- Core_Option_Option_Type.some_0 _28;
    _35 <- ();
    _33 <- ([#"../src/lib.rs" 259 8 260 63] Ghost.new (Seq.(++) (Ghost.inner produced_20) (Seq.singleton i_32)));
    goto BB14
  }
  BB14 {
    produced_20 <- _33;
    _33 <- any Ghost.ghost_ty (Seq.seq usize);
    idx_36 <- i_32;
    _40 <- Vecmap_VecMap_Type.vecmap_v self_1;
    _41 <- idx_36;
    _39 <- ([#"../src/lib.rs" 262 15 262 26] Index0.index _40 _41);
    goto BB15
  }
  BB15 {
    _38 <- (let (a, _) = _39 in a);
    assume { Resolve4.resolve _39 };
    _42 <- Vecmap_KeyRef_Type.keyref_key key_2;
    _37 <- ([#"../src/lib.rs" 262 15 262 39] Gt0.gt _38 _42);
    goto BB16
  }
  BB16 {
    switch (_37)
      | False -> goto BB19
      | True -> goto BB17
      end
  }
  BB17 {
    assume { Resolve3.resolve key_2 };
    _48 <- Vecmap_VecMap_Type.vecmap_v self_1;
    assume { Resolve2.resolve self_1 };
    _49 <- idx_36;
    _47 <- ([#"../src/lib.rs" 263 36 263 47] Index0.index _48 _49);
    goto BB18
  }
  BB18 {
    _46 <- _47;
    assume { Resolve4.resolve _47 };
    key_44 <- (let (a, _) = _46 in a);
    value_45 <- (let (_, a) = _46 in a);
    assume { Resolve4.resolve _46 };
    _52 <- idx_36;
    _53 <- key_44;
    assume { Resolve5.resolve key_44 };
    _51 <- Vecmap_KeyRef_Type.C_KeyRef _53 _52;
    _54 <- value_45;
    assume { Resolve6.resolve value_45 };
    _50 <- (_51, _54);
    _0 <- Core_Option_Option_Type.C_Some _50;
    goto BB20
  }
  BB19 {
    _27 <- ();
    goto BB9
  }
  BB20 {
    return _0
  }
  
end
module Core_Slice_Impl0_First_Interface
  type t
  use seq.Seq
  use prelude.Borrow
  use prelude.Slice
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  use Core_Option_Option_Type as Core_Option_Option_Type
  val first [@cfg:stackify] (self : seq t) : Core_Option_Option_Type.t_option t
    ensures { result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model self) = 0 }
    ensures { forall x : t . result = Core_Option_Option_Type.C_Some x -> Seq.get (ShallowModel0.shallow_model self) 0 = x }
    
end
module Core_Slice_Impl0_First
  type t
  use seq.Seq
  use prelude.Borrow
  use prelude.Slice
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t
  clone CreusotContracts_Model_Impl1_ShallowModel_Interface as ShallowModel0 with
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  use Core_Option_Option_Type as Core_Option_Option_Type
  val first [@cfg:stackify] (self : seq t) : Core_Option_Option_Type.t_option t
    ensures { result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model self) = 0 }
    ensures { forall x : t . result = Core_Option_Option_Type.C_Some x -> Seq.get (ShallowModel0.shallow_model self) 0 = x }
    
end
module Vecmap_Impl1_MinEntry_Interface
  type k
  type v
  use seq.Seq
  use prelude.Borrow
  use mach.int.UInt64
  use mach.int.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Stub as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val min_entry [@cfg:stackify] [#"../src/lib.rs" 309 4 309 55] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"../src/lib.rs" 302 15 302 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 303 4 303 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"../src/lib.rs" 304 4 304 101] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some entry -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) 0 = (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a), let (_, a) = entry in a) }
    ensures { [#"../src/lib.rs" 305 4 305 80] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some entry -> UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = entry in a)) = 0 }
    ensures { [#"../src/lib.rs" 306 4 308 6] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some entry -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)))) }
    
end
module Vecmap_Impl1_MinEntry
  type k
  type v
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use mach.int.Int
  use prelude.IntSize
  use mach.int.UInt64
  use prelude.UIntSize
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel3 with
    type t = (k, v),
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v)
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = seq (k, v),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = k
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_First_Interface as First0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = seq (k, v)
  clone Alloc_Vec_Impl10_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  let rec cfg min_entry [@cfg:stackify] [#"../src/lib.rs" 309 4 309 55] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v)
    requires {[#"../src/lib.rs" 302 15 302 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 303 4 303 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"../src/lib.rs" 304 4 304 101] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some entry -> Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) 0 = (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a), let (_, a) = entry in a) }
    ensures { [#"../src/lib.rs" 305 4 305 80] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some entry -> UInt64.to_int (Vecmap_KeyRef_Type.keyref_min_idx (let (a, _) = entry in a)) = 0 }
    ensures { [#"../src/lib.rs" 306 4 308 6] forall entry : (Vecmap_KeyRef_Type.t_keyref k, v) . result = Core_Option_Option_Type.C_Some entry -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> GeLog0.ge_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model (Vecmap_KeyRef_Type.keyref_key (let (a, _) = entry in a)))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option (Vecmap_KeyRef_Type.t_keyref k, v);
  var self_1 : Vecmap_VecMap_Type.t_vecmap k v;
  var _7 : Core_Option_Option_Type.t_option (k, v);
  var _8 : seq (k, v);
  var _9 : seq (k, v);
  var _10 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _11 : isize;
  var key_12 : k;
  var value_13 : v;
  var _14 : (Vecmap_KeyRef_Type.t_keyref k, v);
  var _15 : Vecmap_KeyRef_Type.t_keyref k;
  var _16 : k;
  var _17 : v;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _10 <- Vecmap_VecMap_Type.vecmap_v self_1;
    assume { Resolve0.resolve self_1 };
    _9 <- ([#"../src/lib.rs" 310 14 310 28] Deref0.deref _10);
    goto BB1
  }
  BB1 {
    _8 <- _9;
    assume { Resolve1.resolve _9 };
    _7 <- ([#"../src/lib.rs" 310 14 310 28] First0.first _8);
    goto BB2
  }
  BB2 {
    switch (_7)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB5
      end
  }
  BB3 {
    assume { Resolve2.resolve _7 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB6
  }
  BB4 {
    assume { Resolve2.resolve _7 };
    absurd
  }
  BB5 {
    key_12 <- (let (a, _) = Core_Option_Option_Type.some_0 _7 in a);
    value_13 <- (let (_, a) = Core_Option_Option_Type.some_0 _7 in a);
    assume { Resolve2.resolve _7 };
    _16 <- key_12;
    assume { Resolve3.resolve key_12 };
    _15 <- Vecmap_KeyRef_Type.C_KeyRef _16 ([#"../src/lib.rs" 311 63 311 64] (0 : usize));
    _17 <- value_13;
    assume { Resolve4.resolve value_13 };
    _14 <- (_15, _17);
    _0 <- Core_Option_Option_Type.C_Some _14;
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Core_Slice_Impl0_Last_Interface
  type t
  use seq.Seq
  use prelude.Borrow
  use mach.int.Int
  use prelude.Slice
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  use Core_Option_Option_Type as Core_Option_Option_Type
  val last [@cfg:stackify] (self : seq t) : Core_Option_Option_Type.t_option t
    ensures { result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model self) = 0 }
    ensures { forall x : t . result = Core_Option_Option_Type.C_Some x -> Seq.get (ShallowModel0.shallow_model self) (Seq.length (ShallowModel0.shallow_model self) - 1) = x }
    
end
module Core_Slice_Impl0_Last
  type t
  use seq.Seq
  use prelude.Borrow
  use mach.int.Int
  use prelude.Slice
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = t
  clone CreusotContracts_Model_Impl1_ShallowModel_Interface as ShallowModel0 with
    type t = seq t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  use Core_Option_Option_Type as Core_Option_Option_Type
  val last [@cfg:stackify] (self : seq t) : Core_Option_Option_Type.t_option t
    ensures { result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model self) = 0 }
    ensures { forall x : t . result = Core_Option_Option_Type.C_Some x -> Seq.get (ShallowModel0.shallow_model self) (Seq.length (ShallowModel0.shallow_model self) - 1) = x }
    
end
module Vecmap_Impl1_MaxKey_Interface
  type k
  type v
  use seq.Seq
  use prelude.Borrow
  use mach.int.Int
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Stub as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_Impl0_DeepModel_Stub as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  val max_key [@cfg:stackify] [#"../src/lib.rs" 323 4 323 39] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option k
    requires {[#"../src/lib.rs" 317 15 317 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 318 4 318 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"../src/lib.rs" 319 4 322 6] forall k : k . result = Core_Option_Option_Type.C_Some k -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model k)) }
    
end
module Vecmap_Impl1_MaxKey
  type k
  type v
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use mach.int.Int
  use prelude.IntSize
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel3 with
    type t = (k, v),
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v)
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy1.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = seq (k, v),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel1 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve4 with
    type self = k
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve3 with
    type self = (k, v)
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve2 with
    type self = Core_Option_Option_Type.t_option (k, v)
  clone Core_Slice_Impl0_Last_Interface as Last0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = seq (k, v)
  clone Alloc_Vec_Impl10_Deref_Interface as Deref0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Model_Impl0_DeepModel as DeepModel0 with
    type t = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    function DeepModel0.deep_model = DeepModel1.deep_model
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel1.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec cfg max_key [@cfg:stackify] [#"../src/lib.rs" 323 4 323 39] (self : Vecmap_VecMap_Type.t_vecmap k v) : Core_Option_Option_Type.t_option k
    requires {[#"../src/lib.rs" 317 15 317 31] IsSorted0.is_sorted self}
    ensures { [#"../src/lib.rs" 318 4 318 55] result = Core_Option_Option_Type.C_None -> Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0 }
    ensures { [#"../src/lib.rs" 319 4 322 6] forall k : k . result = Core_Option_Option_Type.C_Some k -> (forall i : int . i >= 0 /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) -> LeLog0.le_log (Seq.get (KeySeq0.key_seq self) i) (DeepModel0.deep_model k)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Core_Option_Option_Type.t_option k;
  var self_1 : Vecmap_VecMap_Type.t_vecmap k v;
  var _5 : Core_Option_Option_Type.t_option (k, v);
  var _6 : seq (k, v);
  var _7 : seq (k, v);
  var _8 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _9 : isize;
  var e_10 : (k, v);
  var _11 : k;
  var _12 : k;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _8 <- Vecmap_VecMap_Type.vecmap_v self_1;
    assume { Resolve0.resolve self_1 };
    _7 <- ([#"../src/lib.rs" 324 14 324 27] Deref0.deref _8);
    goto BB1
  }
  BB1 {
    _6 <- _7;
    assume { Resolve1.resolve _7 };
    _5 <- ([#"../src/lib.rs" 324 14 324 27] Last0.last _6);
    goto BB2
  }
  BB2 {
    switch (_5)
      | Core_Option_Option_Type.C_None -> goto BB3
      | Core_Option_Option_Type.C_Some _ -> goto BB5
      end
  }
  BB3 {
    assume { Resolve2.resolve _5 };
    _0 <- Core_Option_Option_Type.C_None;
    goto BB6
  }
  BB4 {
    assume { Resolve2.resolve _5 };
    absurd
  }
  BB5 {
    assume { Resolve3.resolve e_10 };
    e_10 <- Core_Option_Option_Type.some_0 _5;
    assume { Resolve2.resolve _5 };
    _12 <- (let (a, _) = e_10 in a);
    assume { Resolve3.resolve e_10 };
    _11 <- _12;
    assume { Resolve4.resolve _12 };
    _0 <- Core_Option_Option_Type.C_Some _11;
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Alloc_Vec_Impl14_Clone_Interface
  type t
  type a
  use prelude.Borrow
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  val clone' [@cfg:stackify] (self : Alloc_Vec_Vec_Type.t_vec t a) : Alloc_Vec_Vec_Type.t_vec t a
    ensures { result = self }
    
end
module Alloc_Vec_Impl14_Clone
  type t
  type a
  use prelude.Borrow
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  val clone' [@cfg:stackify] (self : Alloc_Vec_Vec_Type.t_vec t a) : Alloc_Vec_Vec_Type.t_vec t a
    ensures { result = self }
    
end
module Vecmap_Impl2_Clone_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  val clone' [@cfg:stackify] [#"../src/lib.rs" 406 4 406 27] (self : Vecmap_VecMap_Type.t_vecmap k v) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"../src/lib.rs" 405 14 405 29] result = self }
    
end
module Vecmap_Impl2_Clone
  type k
  type v
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Alloc_Vec_Impl14_Clone_Interface as Clone0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_VecMap_Type.t_vecmap k v
  let rec cfg clone' [@cfg:stackify] [#"../src/lib.rs" 406 4 406 27] (self : Vecmap_VecMap_Type.t_vecmap k v) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"../src/lib.rs" 405 14 405 29] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_VecMap_Type.t_vecmap k v;
  var self_1 : Vecmap_VecMap_Type.t_vecmap k v;
  var _3 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  var _4 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- Vecmap_VecMap_Type.vecmap_v self_1;
    assume { Resolve0.resolve self_1 };
    _3 <- ([#"../src/lib.rs" 407 20 407 34] Clone0.clone' _4);
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_VecMap_Type.C_VecMap _3;
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_Impl4_IsDefault_Stub
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_default [#"../src/lib.rs" 430 4 430 31] (self : Vecmap_VecMap_Type.t_vecmap k v)
end
module Vecmap_Impl4_IsDefault_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  predicate is_default [#"../src/lib.rs" 430 4 430 31] (self : Vecmap_VecMap_Type.t_vecmap k v)
end
module Vecmap_Impl4_IsDefault
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate is_default [#"../src/lib.rs" 430 4 430 31] (self : Vecmap_VecMap_Type.t_vecmap k v) =
    [#"../src/lib.rs" 431 20 431 40] Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v self)) = 0
  val is_default [#"../src/lib.rs" 430 4 430 31] (self : Vecmap_VecMap_Type.t_vecmap k v) : bool
    ensures { result = is_default self }
    
end
module Vecmap_Impl3_Default_Interface
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl4_IsDefault_Stub as IsDefault0 with
    type k = k,
    type v = v
  val default [@cfg:stackify] [#"../src/lib.rs" 420 4 420 24] (_1' : ()) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"../src/lib.rs" 419 14 419 33] IsDefault0.is_default result }
    
end
module Vecmap_Impl3_Default
  type k
  type v
  clone Core_Num_Impl12_Max as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Alloc_Vec_Impl0_New_Interface as New0 with
    type t = (k, v),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl4_IsDefault as IsDefault0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg default [@cfg:stackify] [#"../src/lib.rs" 420 4 420 24] (_1' : ()) : Vecmap_VecMap_Type.t_vecmap k v
    ensures { [#"../src/lib.rs" 419 14 419 33] IsDefault0.is_default result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_VecMap_Type.t_vecmap k v;
  var _2 : Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global);
  {
    goto BB0
  }
  BB0 {
    _2 <- ([#"../src/lib.rs" 421 18 421 28] New0.new ());
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_VecMap_Type.C_VecMap _2;
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_Impl5_Keyref_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  val keyref [@cfg:stackify] [#"../src/lib.rs" 476 4 476 38] (self : Vecmap_Entry_Type.t_entry k v) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"../src/lib.rs" 472 15 475 5] match (self) with
      | Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry map _ _) -> IsSorted0.is_sorted ( * map)
      | Vecmap_Entry_Type.C_Occupied (Vecmap_OccupiedEntry_Type.C_OccupiedEntry map _ _) -> IsSorted0.is_sorted ( * map)
      end}
    
end
module Vecmap_Impl5_Keyref
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.IntSize
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = k
  use Vecmap_Entry_Type as Vecmap_Entry_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_Entry_Type.t_entry k v
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  let rec cfg keyref [@cfg:stackify] [#"../src/lib.rs" 476 4 476 38] (self : Vecmap_Entry_Type.t_entry k v) : Vecmap_KeyRef_Type.t_keyref k
    requires {[#"../src/lib.rs" 472 15 475 5] match (self) with
      | Vecmap_Entry_Type.C_Vacant (Vecmap_VacantEntry_Type.C_VacantEntry map _ _) -> IsSorted0.is_sorted ( * map)
      | Vecmap_Entry_Type.C_Occupied (Vecmap_OccupiedEntry_Type.C_OccupiedEntry map _ _) -> IsSorted0.is_sorted ( * map)
      end}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self_1 : Vecmap_Entry_Type.t_entry k v;
  var _3 : isize;
  var key_4 : k;
  var index_5 : usize;
  var _6 : usize;
  var _7 : k;
  var key_8 : k;
  var index_9 : usize;
  var _10 : usize;
  var _11 : k;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    switch (self_1)
      | Vecmap_Entry_Type.C_Vacant _ -> goto BB3
      | Vecmap_Entry_Type.C_Occupied _ -> goto BB1
      end
  }
  BB1 {
    key_8 <- Vecmap_OccupiedEntry_Type.occupiedentry_key (Vecmap_Entry_Type.occupied_0 self_1);
    index_9 <- Vecmap_OccupiedEntry_Type.occupiedentry_index (Vecmap_Entry_Type.occupied_0 self_1);
    assume { Resolve0.resolve self_1 };
    _10 <- index_9;
    _11 <- key_8;
    assume { Resolve1.resolve key_8 };
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _11 _10;
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    key_4 <- Vecmap_VacantEntry_Type.vacantentry_key (Vecmap_Entry_Type.vacant_0 self_1);
    index_5 <- Vecmap_VacantEntry_Type.vacantentry_index (Vecmap_Entry_Type.vacant_0 self_1);
    assume { Resolve0.resolve self_1 };
    _6 <- index_5;
    _7 <- key_4;
    assume { Resolve1.resolve key_4 };
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _7 _6;
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Vecmap_Impl15_Resolve_Stub
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate resolve [#"../src/lib.rs" 496 4 496 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
end
module Vecmap_Impl15_Resolve_Interface
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  predicate resolve [#"../src/lib.rs" 496 4 496 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v)
end
module Vecmap_Impl15_Resolve
  type k
  type v
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve1 with
    type self = k
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  predicate resolve [#"../src/lib.rs" 496 4 496 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) =
    [#"../src/lib.rs" 495 4 495 16] Resolve0.resolve (Vecmap_VacantEntry_Type.vacantentry_map self) /\ Resolve1.resolve (Vecmap_VacantEntry_Type.vacantentry_key self)
  val resolve [#"../src/lib.rs" 496 4 496 28] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) : bool
    ensures { result = resolve self }
    
end
module Vecmap_Impl7_Insert_Interface
  type k
  type v
  use mach.int.Int
  use mach.int.UInt64
  use prelude.Borrow
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_IsSorted_Stub as IsSorted0 with
    type k = k,
    type v = v
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Stub as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Stub as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl0_KeySeq_Stub as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl6_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  val insert [@cfg:stackify] [#"../src/lib.rs" 526 4 526 33] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) (value : v) : ()
    requires {[#"../src/lib.rs" 520 15 520 31] Invariant0.invariant' self}
    requires {[#"../src/lib.rs" 521 4 522 62] forall i : int . i >= 0 /\ i < UInt64.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"../src/lib.rs" 523 4 524 62] forall i : int . i >= UInt64.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self))) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    ensures { [#"../src/lib.rs" 525 14 525 37] IsSorted0.is_sorted ( ^ Vecmap_VacantEntry_Type.vacantentry_map self) }
    
end
module Vecmap_Impl7_Insert
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.UInt64
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = Vecmap_VecMap_Type.t_vecmap k v
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  use Vecmap_VacantEntry_Type as Vecmap_VacantEntry_Type
  clone Vecmap_Impl15_Resolve as Resolve2 with
    type k = k,
    type v = v,
    predicate Resolve0.resolve = Resolve3.resolve,
    predicate Resolve1.resolve = Resolve0.resolve
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone Vecmap_Impl1_InsertInternal_Interface as InsertInternal0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve1 with
    type self = v
  clone Vecmap_Impl6_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg insert [@cfg:stackify] [#"../src/lib.rs" 526 4 526 33] (self : Vecmap_VacantEntry_Type.t_vacantentry k v) (value : v) : ()
    requires {[#"../src/lib.rs" 520 15 520 31] Invariant0.invariant' self}
    requires {[#"../src/lib.rs" 521 4 522 62] forall i : int . i >= 0 /\ i < UInt64.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) -> LtLog0.lt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    requires {[#"../src/lib.rs" 523 4 524 62] forall i : int . i >= UInt64.to_int (Vecmap_VacantEntry_Type.vacantentry_index self) /\ i < Seq.length (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_VacantEntry_Type.vacantentry_map self))) -> GtLog0.gt_log (Seq.get (KeySeq0.key_seq ( * Vecmap_VacantEntry_Type.vacantentry_map self)) i) (DeepModel0.deep_model (Vecmap_VacantEntry_Type.vacantentry_key self))}
    ensures { [#"../src/lib.rs" 525 14 525 37] IsSorted0.is_sorted ( ^ Vecmap_VacantEntry_Type.vacantentry_map self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : Vecmap_VacantEntry_Type.t_vacantentry k v;
  var value_2 : v;
  var _7 : borrowed (Vecmap_VecMap_Type.t_vecmap k v);
  var _8 : usize;
  var _9 : k;
  var _10 : v;
  {
    self_1 <- self;
    value_2 <- value;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _7 <- borrow_mut ( * Vecmap_VacantEntry_Type.vacantentry_map self_1);
    self_1 <- (let Vecmap_VacantEntry_Type.C_VacantEntry a b c = self_1 in Vecmap_VacantEntry_Type.C_VacantEntry ({ (Vecmap_VacantEntry_Type.vacantentry_map self_1) with current = ( ^ _7) }) b c);
    _8 <- Vecmap_VacantEntry_Type.vacantentry_index self_1;
    assume { Resolve0.resolve _9 };
    _9 <- Vecmap_VacantEntry_Type.vacantentry_key self_1;
    self_1 <- (let Vecmap_VacantEntry_Type.C_VacantEntry a b c = self_1 in Vecmap_VacantEntry_Type.C_VacantEntry a (any k) c);
    assume { Resolve1.resolve _10 };
    _10 <- value_2;
    value_2 <- any v;
    _0 <- ([#"../src/lib.rs" 527 8 527 61] InsertInternal0.insert_internal _7 _8 _9 _10);
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    assume { Resolve2.resolve self_1 };
    return _0
  }
  
end
module Vecmap_Impl9_Replace_Interface
  type k
  type v
  use prelude.Borrow
  use mach.int.UInt64
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl8_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  val replace [@cfg:stackify] [#"../src/lib.rs" 554 4 554 39] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) (value : v) : ()
    requires {[#"../src/lib.rs" 552 4 552 40] Invariant0.invariant' ( * self)}
    ensures { [#"../src/lib.rs" 552 4 552 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 553 14 553 54] (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( ^ self)))) (UInt64.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self))) in a) = value }
    
end
module Vecmap_Impl9_Replace
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  use mach.int.UInt64
  use seq.Seq
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v)
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  clone Core_Slice_Index_Impl2_Output_Type as Output0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = (k, v)
  clone Alloc_Vec_Impl17_IndexMut_Interface as IndexMut0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = Output0.output,
    val Max0.mAX' = Max0.mAX'
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = v
  clone Vecmap_Impl8_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    val Max0.mAX' = Max0.mAX',
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec cfg replace [@cfg:stackify] [#"../src/lib.rs" 554 4 554 39] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) (value : v) : ()
    requires {[#"../src/lib.rs" 552 4 552 40] Invariant0.invariant' ( * self)}
    ensures { [#"../src/lib.rs" 552 4 552 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../src/lib.rs" 553 14 553 54] (let (_, a) = Seq.get (ShallowModel0.shallow_model (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( ^ self)))) (UInt64.to_int (Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self))) in a) = value }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v);
  var value_2 : v;
  var _6 : v;
  var _7 : borrowed (k, v);
  var _8 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  var _9 : usize;
  {
    self_1 <- self;
    value_2 <- value;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _6 };
    _6 <- value_2;
    value_2 <- any v;
    _8 <- borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self_1)));
    self_1 <- { self_1 with current = (let Vecmap_OccupiedEntry_Type.C_OccupiedEntry a b c =  * self_1 in Vecmap_OccupiedEntry_Type.C_OccupiedEntry ({ (Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self_1)) with current = (let Vecmap_VecMap_Type.C_VecMap a =  * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self_1) in Vecmap_VecMap_Type.C_VecMap ( ^ _8)) }) b c) };
    _9 <- Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self_1);
    assume { Resolve1.resolve self_1 };
    _7 <- ([#"../src/lib.rs" 555 8 555 30] IndexMut0.index_mut _8 _9);
    goto BB2
  }
  BB2 {
    assume { Resolve0.resolve (let (_, a) =  * _7 in a) };
    _7 <- { _7 with current = (let (a, b) =  * _7 in (a, _6)) };
    goto BB3
  }
  BB3 {
    assume { Resolve2.resolve _7 };
    goto BB4
  }
  BB4 {
    _0 <- ();
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Vecmap_Impl9_GetMut_Interface
  type k
  type v
  use prelude.Borrow
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone Vecmap_Impl8_Invariant_Stub as Invariant0 with
    type k = k,
    type v = v
  val get_mut [@cfg:stackify] [#"../src/lib.rs" 560 4 560 39] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) : borrowed v
    requires {[#"../src/lib.rs" 559 4 559 40] Invariant0.invariant' ( * self)}
    ensures { [#"../src/lib.rs" 559 4 559 40] Invariant0.invariant' ( ^ self) }
    
end
module Vecmap_Impl9_GetMut
  type k
  type v
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = k
  clone CreusotContracts_Logic_Ord_OrdLogic_GtLog_Interface as GtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_GeLog_Interface as GeLog0 with
    type self = DeepModelTy0.deepModelTy
  use Core_Cmp_Ordering_Type as Core_Cmp_Ordering_Type
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLog_Interface as CmpLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_LeLog_Interface as LeLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_EqCmp_Interface as EqCmp0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym2_Interface as Antisym20 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Antisym1_Interface as Antisym10 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Trans_Interface as Trans0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_Refl_Interface as Refl0 with
    type self = DeepModelTy0.deepModelTy,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGtLog_Interface as CmpGtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GtLog0.gt_log = GtLog0.gt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpGeLog_Interface as CmpGeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate GeLog0.ge_log = GeLog0.ge_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_LtLog_Interface as LtLog0 with
    type self = DeepModelTy0.deepModelTy
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLtLog_Interface as CmpLtLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Logic_Ord_OrdLogic_CmpLeLog_Interface as CmpLeLog0 with
    type self = DeepModelTy0.deepModelTy,
    predicate LeLog0.le_log = LeLog0.le_log,
    function CmpLog0.cmp_log = CmpLog0.cmp_log,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModelTy_Type as ShallowModelTy1 with
    type t = (k, v)
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModelTy_Type as ShallowModelTy0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global
  clone Core_Slice_Index_Impl2_Output_Type as Output0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = (k, v)
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = (k, v)
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_DeepModel_DeepModel_Interface as DeepModel0 with
    type self = k,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl0_KeySeq as KeySeq0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Vecmap_Impl0_IsSorted as IsSorted0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    predicate LtLog0.lt_log = LtLog0.lt_log,
    val Max0.mAX' = Max0.mAX',
    function DeepModel0.deep_model = DeepModel0.deep_model,
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = v
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = (k, v)
  clone Alloc_Vec_Impl17_IndexMut_Interface as IndexMut0 with
    type t = (k, v),
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = Output0.output,
    val Max0.mAX' = Max0.mAX'
  use Vecmap_OccupiedEntry_Type as Vecmap_OccupiedEntry_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Vecmap_OccupiedEntry_Type.t_occupiedentry k v
  clone Vecmap_Impl8_Invariant as Invariant0 with
    type k = k,
    type v = v,
    predicate IsSorted0.is_sorted = IsSorted0.is_sorted,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function KeySeq0.key_seq = KeySeq0.key_seq,
    function DeepModel0.deep_model = DeepModel0.deep_model,
    val Max0.mAX' = Max0.mAX',
    type DeepModelTy0.deepModelTy = DeepModelTy0.deepModelTy
  let rec cfg get_mut [@cfg:stackify] [#"../src/lib.rs" 560 4 560 39] (self : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v)) : borrowed v
    requires {[#"../src/lib.rs" 559 4 559 40] Invariant0.invariant' ( * self)}
    ensures { [#"../src/lib.rs" 559 4 559 40] Invariant0.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : borrowed v;
  var self_1 : borrowed (Vecmap_OccupiedEntry_Type.t_occupiedentry k v);
  var _2 : borrowed v;
  var _5 : borrowed v;
  var _6 : borrowed (k, v);
  var _7 : borrowed (Alloc_Vec_Vec_Type.t_vec (k, v) (Alloc_Alloc_Global_Type.t_global));
  var _8 : usize;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _7 <- borrow_mut (Vecmap_VecMap_Type.vecmap_v ( * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self_1)));
    self_1 <- { self_1 with current = (let Vecmap_OccupiedEntry_Type.C_OccupiedEntry a b c =  * self_1 in Vecmap_OccupiedEntry_Type.C_OccupiedEntry ({ (Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self_1)) with current = (let Vecmap_VecMap_Type.C_VecMap a =  * Vecmap_OccupiedEntry_Type.occupiedentry_map ( * self_1) in Vecmap_VecMap_Type.C_VecMap ( ^ _7)) }) b c) };
    _8 <- Vecmap_OccupiedEntry_Type.occupiedentry_index ( * self_1);
    assume { Resolve0.resolve self_1 };
    _6 <- ([#"../src/lib.rs" 561 13 561 35] IndexMut0.index_mut _7 _8);
    goto BB1
  }
  BB1 {
    _5 <- borrow_mut (let (_, a) =  * _6 in a);
    _6 <- { _6 with current = (let (a, b) =  * _6 in (a,  ^ _5)) };
    assume { Resolve1.resolve _6 };
    _2 <- borrow_mut ( * _5);
    _5 <- { _5 with current = ( ^ _2) };
    assume { Resolve2.resolve _5 };
    _0 <- borrow_mut ( * _2);
    _2 <- { _2 with current = ( ^ _0) };
    assume { Resolve2.resolve _2 };
    return _0
  }
  
end
module Core_Clone_Clone_Clone_Interface
  type self
  use prelude.Borrow
  val clone' [@cfg:stackify] (self : self) : self
    ensures { result = self }
    
end
module Core_Clone_Clone_Clone
  type self
  use prelude.Borrow
  val clone' [@cfg:stackify] (self : self) : self
    ensures { result = self }
    
end
module Core_Clone_Impls_Impl5_Clone_Interface
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  val clone' [@cfg:stackify] (self : usize) : usize
    ensures { result = self }
    
end
module Core_Clone_Impls_Impl5_Clone
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  val clone' [@cfg:stackify] (self : usize) : usize
    ensures { result = self }
    
end
module Vecmap_Impl17_Clone_Interface
  type k
  use prelude.Borrow
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  val clone' [@cfg:stackify] [#"../src/lib.rs" 568 15 568 20] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    ensures { [#"../src/lib.rs" 568 15 568 20] result = self }
    
end
module Vecmap_Impl17_Clone
  type k
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  clone Core_Clone_Impls_Impl5_Clone_Interface as Clone1
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  clone Core_Clone_Clone_Clone_Interface as Clone0 with
    type self = k
  let rec cfg clone' [@cfg:stackify] [#"../src/lib.rs" 568 15 568 20] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    ensures { [#"../src/lib.rs" 568 15 568 20] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self_1 : Vecmap_KeyRef_Type.t_keyref k;
  var _3 : k;
  var _4 : k;
  var _5 : usize;
  var _6 : usize;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- Vecmap_KeyRef_Type.keyref_key self_1;
    _3 <- ([#"../src/lib.rs" 570 4 570 14] Clone0.clone' _4);
    goto BB1
  }
  BB1 {
    _6 <- Vecmap_KeyRef_Type.keyref_min_idx self_1;
    assume { Resolve0.resolve self_1 };
    _5 <- ([#"../src/lib.rs" 571 4 573 18] Clone1.clone' _6);
    goto BB2
  }
  BB2 {
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _3 _5;
    goto BB3
  }
  BB3 {
    return _0
  }
  
end
module Vecmap_Impl11_Cloned_Interface
  type k
  use prelude.Borrow
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  val cloned [@cfg:stackify] [#"../src/lib.rs" 587 4 587 36] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
end
module Vecmap_Impl11_Cloned
  type k
  use prelude.Borrow
  use mach.int.Int
  use prelude.UIntSize
  clone Core_Clone_Clone_Clone_Interface as Clone0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = Vecmap_KeyRef_Type.t_keyref k
  let rec cfg cloned [@cfg:stackify] [#"../src/lib.rs" 587 4 587 36] (self : Vecmap_KeyRef_Type.t_keyref k) : Vecmap_KeyRef_Type.t_keyref k
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var self_1 : Vecmap_KeyRef_Type.t_keyref k;
  var _2 : usize;
  var _3 : k;
  var _4 : k;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _2 <- Vecmap_KeyRef_Type.keyref_min_idx self_1;
    _4 <- Vecmap_KeyRef_Type.keyref_key self_1;
    assume { Resolve0.resolve self_1 };
    _3 <- ([#"../src/lib.rs" 590 17 590 33] Clone0.clone' _4);
    goto BB1
  }
  BB1 {
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _3 _2;
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_Impl14_From_Interface
  type k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  val from [@cfg:stackify] [#"../src/lib.rs" 625 4 625 27] (key : k) : Vecmap_KeyRef_Type.t_keyref k
end
module Vecmap_Impl14_From
  type k
  use mach.int.Int
  use prelude.UIntSize
  clone CreusotContracts_Resolve_Resolve_Resolve_Interface as Resolve0 with
    type self = k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  let rec cfg from [@cfg:stackify] [#"../src/lib.rs" 625 4 625 27] (key : k) : Vecmap_KeyRef_Type.t_keyref k
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Vecmap_KeyRef_Type.t_keyref k;
  var key_1 : k;
  var _2 : k;
  {
    key_1 <- key;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _2 };
    _2 <- key_1;
    key_1 <- any k;
    _0 <- Vecmap_KeyRef_Type.C_KeyRef _2 ([#"../src/lib.rs" 626 29 626 30] (0 : usize));
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    return _0
  }
  
end
module Vecmap_Impl2
  type k
  type v
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl2_Clone_Interface as Clone0 with
    type k = k,
    type v = v
  clone Core_Clone_Clone_Clone_Interface as Clone1 with
    type self = Vecmap_VecMap_Type.t_vecmap k v,
    val clone' = Clone0.clone'
end
module Vecmap_Impl17
  type k
  use Vecmap_KeyRef_Type as Vecmap_KeyRef_Type
  clone Vecmap_Impl17_Clone_Interface as Clone0 with
    type k = k
  clone Core_Clone_Clone_Clone_Interface as Clone1 with
    type self = Vecmap_KeyRef_Type.t_keyref k,
    val clone' = Clone0.clone'
end
module CreusotContracts_Std1_Default_Default_IsDefault_Stub
  type self
  predicate is_default (self : self)
end
module CreusotContracts_Std1_Default_Default_IsDefault_Interface
  type self
  predicate is_default (self : self)
end
module CreusotContracts_Std1_Default_Default_IsDefault
  type self
  predicate is_default (self : self)
  val is_default (self : self) : bool
    ensures { result = is_default self }
    
end
module Core_Default_Default_Default_Interface
  type self
  clone CreusotContracts_Std1_Default_Default_IsDefault_Stub as IsDefault0 with
    type self = self
  val default [@cfg:stackify] (_1' : ()) : self
    ensures { IsDefault0.is_default result }
    
end
module Core_Default_Default_Default
  type self
  clone CreusotContracts_Std1_Default_Default_IsDefault_Interface as IsDefault0 with
    type self = self
  val default [@cfg:stackify] (_1' : ()) : self
    ensures { IsDefault0.is_default result }
    
end
module Vecmap_Impl3
  type k
  type v
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl12_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = (k, v),
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Vecmap_VecMap_Type as Vecmap_VecMap_Type
  clone Vecmap_Impl4_IsDefault as IsDefault0 with
    type k = k,
    type v = v,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Vecmap_Impl3_Default_Interface as Default0 with
    type k = k,
    type v = v,
    predicate IsDefault0.is_default = IsDefault0.is_default
  clone Core_Default_Default_Default_Interface as Default1 with
    type self = Vecmap_VecMap_Type.t_vecmap k v,
    val default = Default0.default,
    predicate IsDefault0.is_default = IsDefault0.is_default
end
module Vecmap_Impl4
  type k
  type v
end
module Vecmap_Impl15
  type k
  type v
end
module Vecmap_Impl6
  type k
  type v
end
module Vecmap_Impl8
  type k
  type v
end
module Vecmap_Impl16
  type k
end
module Vecmap_Impl10
  type k
end
module Vecmap_Impl14
  type k
end
